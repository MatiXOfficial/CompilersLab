Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    PRINT
    RETURN
    STRING
    THEN

Grammar

Rule 0     S' -> start
Rule 1     start -> expr ;
Rule 2     start -> block
Rule 3     start -> start expr ;
Rule 4     start -> start block
Rule 5     expr -> INTNUM
Rule 6     expr -> FLOATNUM
Rule 7     expr -> ID
Rule 8     expr -> ( expr )
Rule 9     expr -> - expr
Rule 10    expr -> expr '
Rule 11    array_interior -> expr , array_interior
Rule 12    array_interior -> expr
Rule 13    expr -> [ array_interior ]
Rule 14    expr -> ID = expr
Rule 15    expr -> ID PLUSASSIGN expr
Rule 16    expr -> ID MINASSIGN expr
Rule 17    expr -> ID MULTASSIGN expr
Rule 18    expr -> ID DIVASSIGN expr
Rule 19    expr -> ID [ INTNUM ] = expr
Rule 20    expr -> ID [ INTNUM ] PLUSASSIGN expr
Rule 21    expr -> ID [ INTNUM ] MINASSIGN expr
Rule 22    expr -> ID [ INTNUM ] MULTASSIGN expr
Rule 23    expr -> ID [ INTNUM ] DIVASSIGN expr
Rule 24    expr -> ID [ INTNUM , INTNUM ] = expr
Rule 25    expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr
Rule 26    expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr
Rule 27    expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr
Rule 28    expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr
Rule 29    expr -> ID = ZEROS ( INTNUM )
Rule 30    expr -> ID = ONES ( INTNUM )
Rule 31    expr -> ID = EYE ( INTNUM )
Rule 32    expr -> expr + expr
Rule 33    expr -> expr - expr
Rule 34    expr -> expr * expr
Rule 35    expr -> expr / expr
Rule 36    expr -> expr MPLUS expr
Rule 37    expr -> expr MMINUS expr
Rule 38    expr -> expr MMLTP expr
Rule 39    expr -> expr MDIV expr
Rule 40    expr -> expr EQ expr
Rule 41    expr -> expr NEQ expr
Rule 42    expr -> expr GTEQ expr
Rule 43    expr -> expr LTEQ expr
Rule 44    expr -> expr > expr
Rule 45    expr -> expr < expr
Rule 46    block -> expr ;
Rule 47    block -> { }
Rule 48    block -> { start }
Rule 49    block -> while_block
Rule 50    block -> if_block
Rule 51    while_block -> WHILE ( expr ) block
Rule 52    if_block -> IF ( expr ) block
Rule 53    else_block -> ELSE block

Terminals, with rules where they appear

'                    : 10
(                    : 8 29 30 31 51 52
)                    : 8 29 30 31 51 52
*                    : 34
+                    : 32
,                    : 11 24 25 26 27 28
-                    : 9 33
/                    : 35
;                    : 1 3 46
<                    : 45
=                    : 14 19 24 29 30 31
>                    : 44
BREAK                : 
CONTINUE             : 
DIVASSIGN            : 18 23 28
ELSE                 : 53
EQ                   : 40
EYE                  : 31
FLOATNUM             : 6
GTEQ                 : 42
ID                   : 7 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
IF                   : 52
INTNUM               : 5 19 20 21 22 23 24 24 25 25 26 26 27 27 28 28 29 30 31
LTEQ                 : 43
MDIV                 : 39
MINASSIGN            : 16 21 26
MMINUS               : 37
MMLTP                : 38
MPLUS                : 36
MULTASSIGN           : 17 22 27
NEQ                  : 41
ONES                 : 30
PLUSASSIGN           : 15 20 25
PRINT                : 
RETURN               : 
STRING               : 
THEN                 : 
WHILE                : 51
ZEROS                : 29
[                    : 13 19 20 21 22 23 24 25 26 27 28
]                    : 13 19 20 21 22 23 24 25 26 27 28
error                : 
{                    : 47 48
}                    : 47 48

Nonterminals, with rules where they appear

array_interior       : 11 13
block                : 2 4 51 52 53
else_block           : 
expr                 : 1 3 8 9 10 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 51 52
if_block             : 50
start                : 3 4 48 0
while_block          : 49

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . expr ;
    (2) start -> . block
    (3) start -> . start expr ;
    (4) start -> . start block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    {               shift and go to state 10
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    start                          shift and go to state 1
    expr                           shift and go to state 2
    block                          shift and go to state 3
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 1

    (0) S' -> start .
    (3) start -> start . expr ;
    (4) start -> start . block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    {               shift and go to state 10
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    expr                           shift and go to state 15
    block                          shift and go to state 16
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 2

    (1) start -> expr . ;
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr
    (46) block -> expr . ;

    ;               shift and go to state 17
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 3

    (2) start -> block .

    INTNUM          reduce using rule 2 (start -> block .)
    FLOATNUM        reduce using rule 2 (start -> block .)
    ID              reduce using rule 2 (start -> block .)
    (               reduce using rule 2 (start -> block .)
    -               reduce using rule 2 (start -> block .)
    [               reduce using rule 2 (start -> block .)
    {               reduce using rule 2 (start -> block .)
    WHILE           reduce using rule 2 (start -> block .)
    IF              reduce using rule 2 (start -> block .)
    $end            reduce using rule 2 (start -> block .)
    }               reduce using rule 2 (start -> block .)


state 4

    (5) expr -> INTNUM .

    ;               reduce using rule 5 (expr -> INTNUM .)
    '               reduce using rule 5 (expr -> INTNUM .)
    +               reduce using rule 5 (expr -> INTNUM .)
    -               reduce using rule 5 (expr -> INTNUM .)
    *               reduce using rule 5 (expr -> INTNUM .)
    /               reduce using rule 5 (expr -> INTNUM .)
    MPLUS           reduce using rule 5 (expr -> INTNUM .)
    MMINUS          reduce using rule 5 (expr -> INTNUM .)
    MMLTP           reduce using rule 5 (expr -> INTNUM .)
    MDIV            reduce using rule 5 (expr -> INTNUM .)
    EQ              reduce using rule 5 (expr -> INTNUM .)
    NEQ             reduce using rule 5 (expr -> INTNUM .)
    GTEQ            reduce using rule 5 (expr -> INTNUM .)
    LTEQ            reduce using rule 5 (expr -> INTNUM .)
    >               reduce using rule 5 (expr -> INTNUM .)
    <               reduce using rule 5 (expr -> INTNUM .)
    )               reduce using rule 5 (expr -> INTNUM .)
    ,               reduce using rule 5 (expr -> INTNUM .)
    ]               reduce using rule 5 (expr -> INTNUM .)


state 5

    (6) expr -> FLOATNUM .

    ;               reduce using rule 6 (expr -> FLOATNUM .)
    '               reduce using rule 6 (expr -> FLOATNUM .)
    +               reduce using rule 6 (expr -> FLOATNUM .)
    -               reduce using rule 6 (expr -> FLOATNUM .)
    *               reduce using rule 6 (expr -> FLOATNUM .)
    /               reduce using rule 6 (expr -> FLOATNUM .)
    MPLUS           reduce using rule 6 (expr -> FLOATNUM .)
    MMINUS          reduce using rule 6 (expr -> FLOATNUM .)
    MMLTP           reduce using rule 6 (expr -> FLOATNUM .)
    MDIV            reduce using rule 6 (expr -> FLOATNUM .)
    EQ              reduce using rule 6 (expr -> FLOATNUM .)
    NEQ             reduce using rule 6 (expr -> FLOATNUM .)
    GTEQ            reduce using rule 6 (expr -> FLOATNUM .)
    LTEQ            reduce using rule 6 (expr -> FLOATNUM .)
    >               reduce using rule 6 (expr -> FLOATNUM .)
    <               reduce using rule 6 (expr -> FLOATNUM .)
    )               reduce using rule 6 (expr -> FLOATNUM .)
    ,               reduce using rule 6 (expr -> FLOATNUM .)
    ]               reduce using rule 6 (expr -> FLOATNUM .)


state 6

    (7) expr -> ID .
    (14) expr -> ID . = expr
    (15) expr -> ID . PLUSASSIGN expr
    (16) expr -> ID . MINASSIGN expr
    (17) expr -> ID . MULTASSIGN expr
    (18) expr -> ID . DIVASSIGN expr
    (19) expr -> ID . [ INTNUM ] = expr
    (20) expr -> ID . [ INTNUM ] PLUSASSIGN expr
    (21) expr -> ID . [ INTNUM ] MINASSIGN expr
    (22) expr -> ID . [ INTNUM ] MULTASSIGN expr
    (23) expr -> ID . [ INTNUM ] DIVASSIGN expr
    (24) expr -> ID . [ INTNUM , INTNUM ] = expr
    (25) expr -> ID . [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> ID . [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> ID . [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> ID . [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> ID . = ZEROS ( INTNUM )
    (30) expr -> ID . = ONES ( INTNUM )
    (31) expr -> ID . = EYE ( INTNUM )

    ;               reduce using rule 7 (expr -> ID .)
    '               reduce using rule 7 (expr -> ID .)
    +               reduce using rule 7 (expr -> ID .)
    -               reduce using rule 7 (expr -> ID .)
    *               reduce using rule 7 (expr -> ID .)
    /               reduce using rule 7 (expr -> ID .)
    MPLUS           reduce using rule 7 (expr -> ID .)
    MMINUS          reduce using rule 7 (expr -> ID .)
    MMLTP           reduce using rule 7 (expr -> ID .)
    MDIV            reduce using rule 7 (expr -> ID .)
    EQ              reduce using rule 7 (expr -> ID .)
    NEQ             reduce using rule 7 (expr -> ID .)
    GTEQ            reduce using rule 7 (expr -> ID .)
    LTEQ            reduce using rule 7 (expr -> ID .)
    >               reduce using rule 7 (expr -> ID .)
    <               reduce using rule 7 (expr -> ID .)
    )               reduce using rule 7 (expr -> ID .)
    ,               reduce using rule 7 (expr -> ID .)
    ]               reduce using rule 7 (expr -> ID .)
    =               shift and go to state 33
    PLUSASSIGN      shift and go to state 34
    MINASSIGN       shift and go to state 35
    MULTASSIGN      shift and go to state 36
    DIVASSIGN       shift and go to state 37
    [               shift and go to state 38


state 7

    (8) expr -> ( . expr )
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 39

state 8

    (9) expr -> - . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 40

state 9

    (13) expr -> [ . array_interior ]
    (11) array_interior -> . expr , array_interior
    (12) array_interior -> . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    array_interior                 shift and go to state 41
    expr                           shift and go to state 42

state 10

    (47) block -> { . }
    (48) block -> { . start }
    (1) start -> . expr ;
    (2) start -> . block
    (3) start -> . start expr ;
    (4) start -> . start block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    }               shift and go to state 43
    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    {               shift and go to state 10
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    start                          shift and go to state 44
    expr                           shift and go to state 2
    block                          shift and go to state 3
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 11

    (49) block -> while_block .

    INTNUM          reduce using rule 49 (block -> while_block .)
    FLOATNUM        reduce using rule 49 (block -> while_block .)
    ID              reduce using rule 49 (block -> while_block .)
    (               reduce using rule 49 (block -> while_block .)
    -               reduce using rule 49 (block -> while_block .)
    [               reduce using rule 49 (block -> while_block .)
    {               reduce using rule 49 (block -> while_block .)
    WHILE           reduce using rule 49 (block -> while_block .)
    IF              reduce using rule 49 (block -> while_block .)
    $end            reduce using rule 49 (block -> while_block .)
    }               reduce using rule 49 (block -> while_block .)


state 12

    (50) block -> if_block .

    INTNUM          reduce using rule 50 (block -> if_block .)
    FLOATNUM        reduce using rule 50 (block -> if_block .)
    ID              reduce using rule 50 (block -> if_block .)
    (               reduce using rule 50 (block -> if_block .)
    -               reduce using rule 50 (block -> if_block .)
    [               reduce using rule 50 (block -> if_block .)
    {               reduce using rule 50 (block -> if_block .)
    WHILE           reduce using rule 50 (block -> if_block .)
    IF              reduce using rule 50 (block -> if_block .)
    $end            reduce using rule 50 (block -> if_block .)
    }               reduce using rule 50 (block -> if_block .)


state 13

    (51) while_block -> WHILE . ( expr ) block

    (               shift and go to state 45


state 14

    (52) if_block -> IF . ( expr ) block

    (               shift and go to state 46


state 15

    (3) start -> start expr . ;
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr
    (46) block -> expr . ;

    ;               shift and go to state 47
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 16

    (4) start -> start block .

    INTNUM          reduce using rule 4 (start -> start block .)
    FLOATNUM        reduce using rule 4 (start -> start block .)
    ID              reduce using rule 4 (start -> start block .)
    (               reduce using rule 4 (start -> start block .)
    -               reduce using rule 4 (start -> start block .)
    [               reduce using rule 4 (start -> start block .)
    {               reduce using rule 4 (start -> start block .)
    WHILE           reduce using rule 4 (start -> start block .)
    IF              reduce using rule 4 (start -> start block .)
    $end            reduce using rule 4 (start -> start block .)
    }               reduce using rule 4 (start -> start block .)


state 17

    (1) start -> expr ; .
    (46) block -> expr ; .

  ! reduce/reduce conflict for INTNUM resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for ID resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for ( resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for - resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for [ resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for { resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for WHILE resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for IF resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for $end resolved using rule 1 (start -> expr ; .)
  ! reduce/reduce conflict for } resolved using rule 1 (start -> expr ; .)
    INTNUM          reduce using rule 1 (start -> expr ; .)
    FLOATNUM        reduce using rule 1 (start -> expr ; .)
    ID              reduce using rule 1 (start -> expr ; .)
    (               reduce using rule 1 (start -> expr ; .)
    -               reduce using rule 1 (start -> expr ; .)
    [               reduce using rule 1 (start -> expr ; .)
    {               reduce using rule 1 (start -> expr ; .)
    WHILE           reduce using rule 1 (start -> expr ; .)
    IF              reduce using rule 1 (start -> expr ; .)
    $end            reduce using rule 1 (start -> expr ; .)
    }               reduce using rule 1 (start -> expr ; .)

  ! INTNUM          [ reduce using rule 46 (block -> expr ; .) ]
  ! FLOATNUM        [ reduce using rule 46 (block -> expr ; .) ]
  ! ID              [ reduce using rule 46 (block -> expr ; .) ]
  ! (               [ reduce using rule 46 (block -> expr ; .) ]
  ! -               [ reduce using rule 46 (block -> expr ; .) ]
  ! [               [ reduce using rule 46 (block -> expr ; .) ]
  ! {               [ reduce using rule 46 (block -> expr ; .) ]
  ! WHILE           [ reduce using rule 46 (block -> expr ; .) ]
  ! IF              [ reduce using rule 46 (block -> expr ; .) ]
  ! $end            [ reduce using rule 46 (block -> expr ; .) ]
  ! }               [ reduce using rule 46 (block -> expr ; .) ]


state 18

    (10) expr -> expr ' .

    ;               reduce using rule 10 (expr -> expr ' .)
    '               reduce using rule 10 (expr -> expr ' .)
    +               reduce using rule 10 (expr -> expr ' .)
    -               reduce using rule 10 (expr -> expr ' .)
    *               reduce using rule 10 (expr -> expr ' .)
    /               reduce using rule 10 (expr -> expr ' .)
    MPLUS           reduce using rule 10 (expr -> expr ' .)
    MMINUS          reduce using rule 10 (expr -> expr ' .)
    MMLTP           reduce using rule 10 (expr -> expr ' .)
    MDIV            reduce using rule 10 (expr -> expr ' .)
    EQ              reduce using rule 10 (expr -> expr ' .)
    NEQ             reduce using rule 10 (expr -> expr ' .)
    GTEQ            reduce using rule 10 (expr -> expr ' .)
    LTEQ            reduce using rule 10 (expr -> expr ' .)
    >               reduce using rule 10 (expr -> expr ' .)
    <               reduce using rule 10 (expr -> expr ' .)
    )               reduce using rule 10 (expr -> expr ' .)
    ,               reduce using rule 10 (expr -> expr ' .)
    ]               reduce using rule 10 (expr -> expr ' .)


state 19

    (32) expr -> expr + . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 48

state 20

    (33) expr -> expr - . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 49

state 21

    (34) expr -> expr * . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 50

state 22

    (35) expr -> expr / . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 51

state 23

    (36) expr -> expr MPLUS . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 52

state 24

    (37) expr -> expr MMINUS . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 53

state 25

    (38) expr -> expr MMLTP . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 54

state 26

    (39) expr -> expr MDIV . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 55

state 27

    (40) expr -> expr EQ . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 56

state 28

    (41) expr -> expr NEQ . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 57

state 29

    (42) expr -> expr GTEQ . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 58

state 30

    (43) expr -> expr LTEQ . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 59

state 31

    (44) expr -> expr > . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 60

state 32

    (45) expr -> expr < . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 61

state 33

    (14) expr -> ID = . expr
    (29) expr -> ID = . ZEROS ( INTNUM )
    (30) expr -> ID = . ONES ( INTNUM )
    (31) expr -> ID = . EYE ( INTNUM )
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    ZEROS           shift and go to state 63
    ONES            shift and go to state 64
    EYE             shift and go to state 65
    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 62

state 34

    (15) expr -> ID PLUSASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 66

state 35

    (16) expr -> ID MINASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 67

state 36

    (17) expr -> ID MULTASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 68

state 37

    (18) expr -> ID DIVASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 69

state 38

    (19) expr -> ID [ . INTNUM ] = expr
    (20) expr -> ID [ . INTNUM ] PLUSASSIGN expr
    (21) expr -> ID [ . INTNUM ] MINASSIGN expr
    (22) expr -> ID [ . INTNUM ] MULTASSIGN expr
    (23) expr -> ID [ . INTNUM ] DIVASSIGN expr
    (24) expr -> ID [ . INTNUM , INTNUM ] = expr
    (25) expr -> ID [ . INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> ID [ . INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> ID [ . INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> ID [ . INTNUM , INTNUM ] DIVASSIGN expr

    INTNUM          shift and go to state 70


state 39

    (8) expr -> ( expr . )
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    )               shift and go to state 71
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 40

    (9) expr -> - expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 9 (expr -> - expr .)
    +               reduce using rule 9 (expr -> - expr .)
    -               reduce using rule 9 (expr -> - expr .)
    MPLUS           reduce using rule 9 (expr -> - expr .)
    MMINUS          reduce using rule 9 (expr -> - expr .)
    EQ              reduce using rule 9 (expr -> - expr .)
    NEQ             reduce using rule 9 (expr -> - expr .)
    GTEQ            reduce using rule 9 (expr -> - expr .)
    LTEQ            reduce using rule 9 (expr -> - expr .)
    >               reduce using rule 9 (expr -> - expr .)
    <               reduce using rule 9 (expr -> - expr .)
    )               reduce using rule 9 (expr -> - expr .)
    ,               reduce using rule 9 (expr -> - expr .)
    ]               reduce using rule 9 (expr -> - expr .)
    '               shift and go to state 18
    *               shift and go to state 21
    /               shift and go to state 22
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 9 (expr -> - expr .) ]
  ! *               [ reduce using rule 9 (expr -> - expr .) ]
  ! /               [ reduce using rule 9 (expr -> - expr .) ]
  ! MMLTP           [ reduce using rule 9 (expr -> - expr .) ]
  ! MDIV            [ reduce using rule 9 (expr -> - expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 41

    (13) expr -> [ array_interior . ]

    ]               shift and go to state 72


state 42

    (11) array_interior -> expr . , array_interior
    (12) array_interior -> expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ,               shift and go to state 73
    ]               reduce using rule 12 (array_interior -> expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 43

    (47) block -> { } .

    INTNUM          reduce using rule 47 (block -> { } .)
    FLOATNUM        reduce using rule 47 (block -> { } .)
    ID              reduce using rule 47 (block -> { } .)
    (               reduce using rule 47 (block -> { } .)
    -               reduce using rule 47 (block -> { } .)
    [               reduce using rule 47 (block -> { } .)
    {               reduce using rule 47 (block -> { } .)
    WHILE           reduce using rule 47 (block -> { } .)
    IF              reduce using rule 47 (block -> { } .)
    $end            reduce using rule 47 (block -> { } .)
    }               reduce using rule 47 (block -> { } .)


state 44

    (48) block -> { start . }
    (3) start -> start . expr ;
    (4) start -> start . block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    }               shift and go to state 74
    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    {               shift and go to state 10
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    expr                           shift and go to state 15
    block                          shift and go to state 16
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 45

    (51) while_block -> WHILE ( . expr ) block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 75

state 46

    (52) if_block -> IF ( . expr ) block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 76

state 47

    (3) start -> start expr ; .
    (46) block -> expr ; .

  ! reduce/reduce conflict for INTNUM resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for FLOATNUM resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for ID resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for ( resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for - resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for [ resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for { resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for IF resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for $end resolved using rule 3 (start -> start expr ; .)
  ! reduce/reduce conflict for } resolved using rule 3 (start -> start expr ; .)
    INTNUM          reduce using rule 3 (start -> start expr ; .)
    FLOATNUM        reduce using rule 3 (start -> start expr ; .)
    ID              reduce using rule 3 (start -> start expr ; .)
    (               reduce using rule 3 (start -> start expr ; .)
    -               reduce using rule 3 (start -> start expr ; .)
    [               reduce using rule 3 (start -> start expr ; .)
    {               reduce using rule 3 (start -> start expr ; .)
    WHILE           reduce using rule 3 (start -> start expr ; .)
    IF              reduce using rule 3 (start -> start expr ; .)
    $end            reduce using rule 3 (start -> start expr ; .)
    }               reduce using rule 3 (start -> start expr ; .)

  ! INTNUM          [ reduce using rule 46 (block -> expr ; .) ]
  ! FLOATNUM        [ reduce using rule 46 (block -> expr ; .) ]
  ! ID              [ reduce using rule 46 (block -> expr ; .) ]
  ! (               [ reduce using rule 46 (block -> expr ; .) ]
  ! -               [ reduce using rule 46 (block -> expr ; .) ]
  ! [               [ reduce using rule 46 (block -> expr ; .) ]
  ! {               [ reduce using rule 46 (block -> expr ; .) ]
  ! WHILE           [ reduce using rule 46 (block -> expr ; .) ]
  ! IF              [ reduce using rule 46 (block -> expr ; .) ]
  ! $end            [ reduce using rule 46 (block -> expr ; .) ]
  ! }               [ reduce using rule 46 (block -> expr ; .) ]


state 48

    (32) expr -> expr + expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 32 (expr -> expr + expr .)
    +               reduce using rule 32 (expr -> expr + expr .)
    -               reduce using rule 32 (expr -> expr + expr .)
    MPLUS           reduce using rule 32 (expr -> expr + expr .)
    MMINUS          reduce using rule 32 (expr -> expr + expr .)
    EQ              reduce using rule 32 (expr -> expr + expr .)
    NEQ             reduce using rule 32 (expr -> expr + expr .)
    GTEQ            reduce using rule 32 (expr -> expr + expr .)
    LTEQ            reduce using rule 32 (expr -> expr + expr .)
    >               reduce using rule 32 (expr -> expr + expr .)
    <               reduce using rule 32 (expr -> expr + expr .)
    )               reduce using rule 32 (expr -> expr + expr .)
    ,               reduce using rule 32 (expr -> expr + expr .)
    ]               reduce using rule 32 (expr -> expr + expr .)
    '               shift and go to state 18
    *               shift and go to state 21
    /               shift and go to state 22
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 32 (expr -> expr + expr .) ]
  ! *               [ reduce using rule 32 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 32 (expr -> expr + expr .) ]
  ! MMLTP           [ reduce using rule 32 (expr -> expr + expr .) ]
  ! MDIV            [ reduce using rule 32 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 49

    (33) expr -> expr - expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 33 (expr -> expr - expr .)
    +               reduce using rule 33 (expr -> expr - expr .)
    -               reduce using rule 33 (expr -> expr - expr .)
    MPLUS           reduce using rule 33 (expr -> expr - expr .)
    MMINUS          reduce using rule 33 (expr -> expr - expr .)
    EQ              reduce using rule 33 (expr -> expr - expr .)
    NEQ             reduce using rule 33 (expr -> expr - expr .)
    GTEQ            reduce using rule 33 (expr -> expr - expr .)
    LTEQ            reduce using rule 33 (expr -> expr - expr .)
    >               reduce using rule 33 (expr -> expr - expr .)
    <               reduce using rule 33 (expr -> expr - expr .)
    )               reduce using rule 33 (expr -> expr - expr .)
    ,               reduce using rule 33 (expr -> expr - expr .)
    ]               reduce using rule 33 (expr -> expr - expr .)
    '               shift and go to state 18
    *               shift and go to state 21
    /               shift and go to state 22
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 33 (expr -> expr - expr .) ]
  ! *               [ reduce using rule 33 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 33 (expr -> expr - expr .) ]
  ! MMLTP           [ reduce using rule 33 (expr -> expr - expr .) ]
  ! MDIV            [ reduce using rule 33 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 50

    (34) expr -> expr * expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 34 (expr -> expr * expr .)
    +               reduce using rule 34 (expr -> expr * expr .)
    -               reduce using rule 34 (expr -> expr * expr .)
    *               reduce using rule 34 (expr -> expr * expr .)
    /               reduce using rule 34 (expr -> expr * expr .)
    MPLUS           reduce using rule 34 (expr -> expr * expr .)
    MMINUS          reduce using rule 34 (expr -> expr * expr .)
    MMLTP           reduce using rule 34 (expr -> expr * expr .)
    MDIV            reduce using rule 34 (expr -> expr * expr .)
    EQ              reduce using rule 34 (expr -> expr * expr .)
    NEQ             reduce using rule 34 (expr -> expr * expr .)
    GTEQ            reduce using rule 34 (expr -> expr * expr .)
    LTEQ            reduce using rule 34 (expr -> expr * expr .)
    >               reduce using rule 34 (expr -> expr * expr .)
    <               reduce using rule 34 (expr -> expr * expr .)
    )               reduce using rule 34 (expr -> expr * expr .)
    ,               reduce using rule 34 (expr -> expr * expr .)
    ]               reduce using rule 34 (expr -> expr * expr .)
    '               shift and go to state 18

  ! '               [ reduce using rule 34 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! /               [ shift and go to state 22 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! MMLTP           [ shift and go to state 25 ]
  ! MDIV            [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 51

    (35) expr -> expr / expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 35 (expr -> expr / expr .)
    +               reduce using rule 35 (expr -> expr / expr .)
    -               reduce using rule 35 (expr -> expr / expr .)
    *               reduce using rule 35 (expr -> expr / expr .)
    /               reduce using rule 35 (expr -> expr / expr .)
    MPLUS           reduce using rule 35 (expr -> expr / expr .)
    MMINUS          reduce using rule 35 (expr -> expr / expr .)
    MMLTP           reduce using rule 35 (expr -> expr / expr .)
    MDIV            reduce using rule 35 (expr -> expr / expr .)
    EQ              reduce using rule 35 (expr -> expr / expr .)
    NEQ             reduce using rule 35 (expr -> expr / expr .)
    GTEQ            reduce using rule 35 (expr -> expr / expr .)
    LTEQ            reduce using rule 35 (expr -> expr / expr .)
    >               reduce using rule 35 (expr -> expr / expr .)
    <               reduce using rule 35 (expr -> expr / expr .)
    )               reduce using rule 35 (expr -> expr / expr .)
    ,               reduce using rule 35 (expr -> expr / expr .)
    ]               reduce using rule 35 (expr -> expr / expr .)
    '               shift and go to state 18

  ! '               [ reduce using rule 35 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! /               [ shift and go to state 22 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! MMLTP           [ shift and go to state 25 ]
  ! MDIV            [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 52

    (36) expr -> expr MPLUS expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 36 (expr -> expr MPLUS expr .)
    +               reduce using rule 36 (expr -> expr MPLUS expr .)
    -               reduce using rule 36 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 36 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 36 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 36 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 36 (expr -> expr MPLUS expr .)
    GTEQ            reduce using rule 36 (expr -> expr MPLUS expr .)
    LTEQ            reduce using rule 36 (expr -> expr MPLUS expr .)
    >               reduce using rule 36 (expr -> expr MPLUS expr .)
    <               reduce using rule 36 (expr -> expr MPLUS expr .)
    )               reduce using rule 36 (expr -> expr MPLUS expr .)
    ,               reduce using rule 36 (expr -> expr MPLUS expr .)
    ]               reduce using rule 36 (expr -> expr MPLUS expr .)
    '               shift and go to state 18
    *               shift and go to state 21
    /               shift and go to state 22
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 36 (expr -> expr MPLUS expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr MPLUS expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr MPLUS expr .) ]
  ! MMLTP           [ reduce using rule 36 (expr -> expr MPLUS expr .) ]
  ! MDIV            [ reduce using rule 36 (expr -> expr MPLUS expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 53

    (37) expr -> expr MMINUS expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 37 (expr -> expr MMINUS expr .)
    +               reduce using rule 37 (expr -> expr MMINUS expr .)
    -               reduce using rule 37 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 37 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 37 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 37 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 37 (expr -> expr MMINUS expr .)
    GTEQ            reduce using rule 37 (expr -> expr MMINUS expr .)
    LTEQ            reduce using rule 37 (expr -> expr MMINUS expr .)
    >               reduce using rule 37 (expr -> expr MMINUS expr .)
    <               reduce using rule 37 (expr -> expr MMINUS expr .)
    )               reduce using rule 37 (expr -> expr MMINUS expr .)
    ,               reduce using rule 37 (expr -> expr MMINUS expr .)
    ]               reduce using rule 37 (expr -> expr MMINUS expr .)
    '               shift and go to state 18
    *               shift and go to state 21
    /               shift and go to state 22
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 37 (expr -> expr MMINUS expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr MMINUS expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr MMINUS expr .) ]
  ! MMLTP           [ reduce using rule 37 (expr -> expr MMINUS expr .) ]
  ! MDIV            [ reduce using rule 37 (expr -> expr MMINUS expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 54

    (38) expr -> expr MMLTP expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 38 (expr -> expr MMLTP expr .)
    +               reduce using rule 38 (expr -> expr MMLTP expr .)
    -               reduce using rule 38 (expr -> expr MMLTP expr .)
    *               reduce using rule 38 (expr -> expr MMLTP expr .)
    /               reduce using rule 38 (expr -> expr MMLTP expr .)
    MPLUS           reduce using rule 38 (expr -> expr MMLTP expr .)
    MMINUS          reduce using rule 38 (expr -> expr MMLTP expr .)
    MMLTP           reduce using rule 38 (expr -> expr MMLTP expr .)
    MDIV            reduce using rule 38 (expr -> expr MMLTP expr .)
    EQ              reduce using rule 38 (expr -> expr MMLTP expr .)
    NEQ             reduce using rule 38 (expr -> expr MMLTP expr .)
    GTEQ            reduce using rule 38 (expr -> expr MMLTP expr .)
    LTEQ            reduce using rule 38 (expr -> expr MMLTP expr .)
    >               reduce using rule 38 (expr -> expr MMLTP expr .)
    <               reduce using rule 38 (expr -> expr MMLTP expr .)
    )               reduce using rule 38 (expr -> expr MMLTP expr .)
    ,               reduce using rule 38 (expr -> expr MMLTP expr .)
    ]               reduce using rule 38 (expr -> expr MMLTP expr .)
    '               shift and go to state 18

  ! '               [ reduce using rule 38 (expr -> expr MMLTP expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! /               [ shift and go to state 22 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! MMLTP           [ shift and go to state 25 ]
  ! MDIV            [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 55

    (39) expr -> expr MDIV expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 39 (expr -> expr MDIV expr .)
    +               reduce using rule 39 (expr -> expr MDIV expr .)
    -               reduce using rule 39 (expr -> expr MDIV expr .)
    *               reduce using rule 39 (expr -> expr MDIV expr .)
    /               reduce using rule 39 (expr -> expr MDIV expr .)
    MPLUS           reduce using rule 39 (expr -> expr MDIV expr .)
    MMINUS          reduce using rule 39 (expr -> expr MDIV expr .)
    MMLTP           reduce using rule 39 (expr -> expr MDIV expr .)
    MDIV            reduce using rule 39 (expr -> expr MDIV expr .)
    EQ              reduce using rule 39 (expr -> expr MDIV expr .)
    NEQ             reduce using rule 39 (expr -> expr MDIV expr .)
    GTEQ            reduce using rule 39 (expr -> expr MDIV expr .)
    LTEQ            reduce using rule 39 (expr -> expr MDIV expr .)
    >               reduce using rule 39 (expr -> expr MDIV expr .)
    <               reduce using rule 39 (expr -> expr MDIV expr .)
    )               reduce using rule 39 (expr -> expr MDIV expr .)
    ,               reduce using rule 39 (expr -> expr MDIV expr .)
    ]               reduce using rule 39 (expr -> expr MDIV expr .)
    '               shift and go to state 18

  ! '               [ reduce using rule 39 (expr -> expr MDIV expr .) ]
  ! +               [ shift and go to state 19 ]
  ! -               [ shift and go to state 20 ]
  ! *               [ shift and go to state 21 ]
  ! /               [ shift and go to state 22 ]
  ! MPLUS           [ shift and go to state 23 ]
  ! MMINUS          [ shift and go to state 24 ]
  ! MMLTP           [ shift and go to state 25 ]
  ! MDIV            [ shift and go to state 26 ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 56

    (40) expr -> expr EQ expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 40 (expr -> expr EQ expr .)
    )               reduce using rule 40 (expr -> expr EQ expr .)
    ,               reduce using rule 40 (expr -> expr EQ expr .)
    ]               reduce using rule 40 (expr -> expr EQ expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! MPLUS           [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! MMINUS          [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! MMLTP           [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! MDIV            [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! EQ              [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! NEQ             [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! GTEQ            [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! LTEQ            [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! >               [ reduce using rule 40 (expr -> expr EQ expr .) ]
  ! <               [ reduce using rule 40 (expr -> expr EQ expr .) ]


state 57

    (41) expr -> expr NEQ expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 41 (expr -> expr NEQ expr .)
    )               reduce using rule 41 (expr -> expr NEQ expr .)
    ,               reduce using rule 41 (expr -> expr NEQ expr .)
    ]               reduce using rule 41 (expr -> expr NEQ expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! +               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! MPLUS           [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! MMINUS          [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! MMLTP           [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! MDIV            [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! EQ              [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! NEQ             [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! GTEQ            [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! LTEQ            [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! >               [ reduce using rule 41 (expr -> expr NEQ expr .) ]
  ! <               [ reduce using rule 41 (expr -> expr NEQ expr .) ]


state 58

    (42) expr -> expr GTEQ expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 42 (expr -> expr GTEQ expr .)
    )               reduce using rule 42 (expr -> expr GTEQ expr .)
    ,               reduce using rule 42 (expr -> expr GTEQ expr .)
    ]               reduce using rule 42 (expr -> expr GTEQ expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! +               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! MPLUS           [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! MMINUS          [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! MMLTP           [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! MDIV            [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! EQ              [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! NEQ             [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! GTEQ            [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! LTEQ            [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! >               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]
  ! <               [ reduce using rule 42 (expr -> expr GTEQ expr .) ]


state 59

    (43) expr -> expr LTEQ expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 43 (expr -> expr LTEQ expr .)
    )               reduce using rule 43 (expr -> expr LTEQ expr .)
    ,               reduce using rule 43 (expr -> expr LTEQ expr .)
    ]               reduce using rule 43 (expr -> expr LTEQ expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! +               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! -               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! *               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! MPLUS           [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! MMINUS          [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! MMLTP           [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! MDIV            [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! EQ              [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! NEQ             [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! GTEQ            [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! LTEQ            [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! >               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]
  ! <               [ reduce using rule 43 (expr -> expr LTEQ expr .) ]


state 60

    (44) expr -> expr > expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 44 (expr -> expr > expr .)
    )               reduce using rule 44 (expr -> expr > expr .)
    ,               reduce using rule 44 (expr -> expr > expr .)
    ]               reduce using rule 44 (expr -> expr > expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! +               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! MPLUS           [ reduce using rule 44 (expr -> expr > expr .) ]
  ! MMINUS          [ reduce using rule 44 (expr -> expr > expr .) ]
  ! MMLTP           [ reduce using rule 44 (expr -> expr > expr .) ]
  ! MDIV            [ reduce using rule 44 (expr -> expr > expr .) ]
  ! EQ              [ reduce using rule 44 (expr -> expr > expr .) ]
  ! NEQ             [ reduce using rule 44 (expr -> expr > expr .) ]
  ! GTEQ            [ reduce using rule 44 (expr -> expr > expr .) ]
  ! LTEQ            [ reduce using rule 44 (expr -> expr > expr .) ]
  ! >               [ reduce using rule 44 (expr -> expr > expr .) ]
  ! <               [ reduce using rule 44 (expr -> expr > expr .) ]


state 61

    (45) expr -> expr < expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MMLTP resolved as shift
  ! shift/reduce conflict for MDIV resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for GTEQ resolved as shift
  ! shift/reduce conflict for LTEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 45 (expr -> expr < expr .)
    )               reduce using rule 45 (expr -> expr < expr .)
    ,               reduce using rule 45 (expr -> expr < expr .)
    ]               reduce using rule 45 (expr -> expr < expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32

  ! '               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! +               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! MPLUS           [ reduce using rule 45 (expr -> expr < expr .) ]
  ! MMINUS          [ reduce using rule 45 (expr -> expr < expr .) ]
  ! MMLTP           [ reduce using rule 45 (expr -> expr < expr .) ]
  ! MDIV            [ reduce using rule 45 (expr -> expr < expr .) ]
  ! EQ              [ reduce using rule 45 (expr -> expr < expr .) ]
  ! NEQ             [ reduce using rule 45 (expr -> expr < expr .) ]
  ! GTEQ            [ reduce using rule 45 (expr -> expr < expr .) ]
  ! LTEQ            [ reduce using rule 45 (expr -> expr < expr .) ]
  ! >               [ reduce using rule 45 (expr -> expr < expr .) ]
  ! <               [ reduce using rule 45 (expr -> expr < expr .) ]


state 62

    (14) expr -> ID = expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 14 (expr -> ID = expr .)
    EQ              reduce using rule 14 (expr -> ID = expr .)
    NEQ             reduce using rule 14 (expr -> ID = expr .)
    GTEQ            reduce using rule 14 (expr -> ID = expr .)
    LTEQ            reduce using rule 14 (expr -> ID = expr .)
    >               reduce using rule 14 (expr -> ID = expr .)
    <               reduce using rule 14 (expr -> ID = expr .)
    )               reduce using rule 14 (expr -> ID = expr .)
    ,               reduce using rule 14 (expr -> ID = expr .)
    ]               reduce using rule 14 (expr -> ID = expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 14 (expr -> ID = expr .) ]
  ! +               [ reduce using rule 14 (expr -> ID = expr .) ]
  ! -               [ reduce using rule 14 (expr -> ID = expr .) ]
  ! *               [ reduce using rule 14 (expr -> ID = expr .) ]
  ! /               [ reduce using rule 14 (expr -> ID = expr .) ]
  ! MPLUS           [ reduce using rule 14 (expr -> ID = expr .) ]
  ! MMINUS          [ reduce using rule 14 (expr -> ID = expr .) ]
  ! MMLTP           [ reduce using rule 14 (expr -> ID = expr .) ]
  ! MDIV            [ reduce using rule 14 (expr -> ID = expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 63

    (29) expr -> ID = ZEROS . ( INTNUM )

    (               shift and go to state 77


state 64

    (30) expr -> ID = ONES . ( INTNUM )

    (               shift and go to state 78


state 65

    (31) expr -> ID = EYE . ( INTNUM )

    (               shift and go to state 79


state 66

    (15) expr -> ID PLUSASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    EQ              reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    NEQ             reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    GTEQ            reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    LTEQ            reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    >               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    <               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    )               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    ,               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    ]               reduce using rule 15 (expr -> ID PLUSASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! +               [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! -               [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! *               [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! /               [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! MDIV            [ reduce using rule 15 (expr -> ID PLUSASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 67

    (16) expr -> ID MINASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    EQ              reduce using rule 16 (expr -> ID MINASSIGN expr .)
    NEQ             reduce using rule 16 (expr -> ID MINASSIGN expr .)
    GTEQ            reduce using rule 16 (expr -> ID MINASSIGN expr .)
    LTEQ            reduce using rule 16 (expr -> ID MINASSIGN expr .)
    >               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    <               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    )               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    ,               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    ]               reduce using rule 16 (expr -> ID MINASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! +               [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! -               [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! *               [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! /               [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! MDIV            [ reduce using rule 16 (expr -> ID MINASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 68

    (17) expr -> ID MULTASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    EQ              reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    NEQ             reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    GTEQ            reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    LTEQ            reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    >               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    <               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    )               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    ,               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    ]               reduce using rule 17 (expr -> ID MULTASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! +               [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! -               [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! *               [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! /               [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! MDIV            [ reduce using rule 17 (expr -> ID MULTASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 69

    (18) expr -> ID DIVASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    EQ              reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    NEQ             reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    GTEQ            reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    LTEQ            reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    >               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    <               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    )               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    ,               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    ]               reduce using rule 18 (expr -> ID DIVASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! +               [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! -               [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! *               [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! /               [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! MDIV            [ reduce using rule 18 (expr -> ID DIVASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 70

    (19) expr -> ID [ INTNUM . ] = expr
    (20) expr -> ID [ INTNUM . ] PLUSASSIGN expr
    (21) expr -> ID [ INTNUM . ] MINASSIGN expr
    (22) expr -> ID [ INTNUM . ] MULTASSIGN expr
    (23) expr -> ID [ INTNUM . ] DIVASSIGN expr
    (24) expr -> ID [ INTNUM . , INTNUM ] = expr
    (25) expr -> ID [ INTNUM . , INTNUM ] PLUSASSIGN expr
    (26) expr -> ID [ INTNUM . , INTNUM ] MINASSIGN expr
    (27) expr -> ID [ INTNUM . , INTNUM ] MULTASSIGN expr
    (28) expr -> ID [ INTNUM . , INTNUM ] DIVASSIGN expr

    ]               shift and go to state 80
    ,               shift and go to state 81


state 71

    (8) expr -> ( expr ) .

    ;               reduce using rule 8 (expr -> ( expr ) .)
    '               reduce using rule 8 (expr -> ( expr ) .)
    +               reduce using rule 8 (expr -> ( expr ) .)
    -               reduce using rule 8 (expr -> ( expr ) .)
    *               reduce using rule 8 (expr -> ( expr ) .)
    /               reduce using rule 8 (expr -> ( expr ) .)
    MPLUS           reduce using rule 8 (expr -> ( expr ) .)
    MMINUS          reduce using rule 8 (expr -> ( expr ) .)
    MMLTP           reduce using rule 8 (expr -> ( expr ) .)
    MDIV            reduce using rule 8 (expr -> ( expr ) .)
    EQ              reduce using rule 8 (expr -> ( expr ) .)
    NEQ             reduce using rule 8 (expr -> ( expr ) .)
    GTEQ            reduce using rule 8 (expr -> ( expr ) .)
    LTEQ            reduce using rule 8 (expr -> ( expr ) .)
    >               reduce using rule 8 (expr -> ( expr ) .)
    <               reduce using rule 8 (expr -> ( expr ) .)
    )               reduce using rule 8 (expr -> ( expr ) .)
    ,               reduce using rule 8 (expr -> ( expr ) .)
    ]               reduce using rule 8 (expr -> ( expr ) .)


state 72

    (13) expr -> [ array_interior ] .

    ;               reduce using rule 13 (expr -> [ array_interior ] .)
    '               reduce using rule 13 (expr -> [ array_interior ] .)
    +               reduce using rule 13 (expr -> [ array_interior ] .)
    -               reduce using rule 13 (expr -> [ array_interior ] .)
    *               reduce using rule 13 (expr -> [ array_interior ] .)
    /               reduce using rule 13 (expr -> [ array_interior ] .)
    MPLUS           reduce using rule 13 (expr -> [ array_interior ] .)
    MMINUS          reduce using rule 13 (expr -> [ array_interior ] .)
    MMLTP           reduce using rule 13 (expr -> [ array_interior ] .)
    MDIV            reduce using rule 13 (expr -> [ array_interior ] .)
    EQ              reduce using rule 13 (expr -> [ array_interior ] .)
    NEQ             reduce using rule 13 (expr -> [ array_interior ] .)
    GTEQ            reduce using rule 13 (expr -> [ array_interior ] .)
    LTEQ            reduce using rule 13 (expr -> [ array_interior ] .)
    >               reduce using rule 13 (expr -> [ array_interior ] .)
    <               reduce using rule 13 (expr -> [ array_interior ] .)
    )               reduce using rule 13 (expr -> [ array_interior ] .)
    ,               reduce using rule 13 (expr -> [ array_interior ] .)
    ]               reduce using rule 13 (expr -> [ array_interior ] .)


state 73

    (11) array_interior -> expr , . array_interior
    (11) array_interior -> . expr , array_interior
    (12) array_interior -> . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 42
    array_interior                 shift and go to state 82

state 74

    (48) block -> { start } .

    INTNUM          reduce using rule 48 (block -> { start } .)
    FLOATNUM        reduce using rule 48 (block -> { start } .)
    ID              reduce using rule 48 (block -> { start } .)
    (               reduce using rule 48 (block -> { start } .)
    -               reduce using rule 48 (block -> { start } .)
    [               reduce using rule 48 (block -> { start } .)
    {               reduce using rule 48 (block -> { start } .)
    WHILE           reduce using rule 48 (block -> { start } .)
    IF              reduce using rule 48 (block -> { start } .)
    $end            reduce using rule 48 (block -> { start } .)
    }               reduce using rule 48 (block -> { start } .)


state 75

    (51) while_block -> WHILE ( expr . ) block
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    )               shift and go to state 83
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 76

    (52) if_block -> IF ( expr . ) block
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    )               shift and go to state 84
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 77

    (29) expr -> ID = ZEROS ( . INTNUM )

    INTNUM          shift and go to state 85


state 78

    (30) expr -> ID = ONES ( . INTNUM )

    INTNUM          shift and go to state 86


state 79

    (31) expr -> ID = EYE ( . INTNUM )

    INTNUM          shift and go to state 87


state 80

    (19) expr -> ID [ INTNUM ] . = expr
    (20) expr -> ID [ INTNUM ] . PLUSASSIGN expr
    (21) expr -> ID [ INTNUM ] . MINASSIGN expr
    (22) expr -> ID [ INTNUM ] . MULTASSIGN expr
    (23) expr -> ID [ INTNUM ] . DIVASSIGN expr

    =               shift and go to state 88
    PLUSASSIGN      shift and go to state 89
    MINASSIGN       shift and go to state 90
    MULTASSIGN      shift and go to state 91
    DIVASSIGN       shift and go to state 92


state 81

    (24) expr -> ID [ INTNUM , . INTNUM ] = expr
    (25) expr -> ID [ INTNUM , . INTNUM ] PLUSASSIGN expr
    (26) expr -> ID [ INTNUM , . INTNUM ] MINASSIGN expr
    (27) expr -> ID [ INTNUM , . INTNUM ] MULTASSIGN expr
    (28) expr -> ID [ INTNUM , . INTNUM ] DIVASSIGN expr

    INTNUM          shift and go to state 93


state 82

    (11) array_interior -> expr , array_interior .

    ]               reduce using rule 11 (array_interior -> expr , array_interior .)


state 83

    (51) while_block -> WHILE ( expr ) . block
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    {               shift and go to state 10
    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    expr                           shift and go to state 94
    block                          shift and go to state 95
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 84

    (52) if_block -> IF ( expr ) . block
    (46) block -> . expr ;
    (47) block -> . { }
    (48) block -> . { start }
    (49) block -> . while_block
    (50) block -> . if_block
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr
    (51) while_block -> . WHILE ( expr ) block
    (52) if_block -> . IF ( expr ) block

    {               shift and go to state 10
    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9
    WHILE           shift and go to state 13
    IF              shift and go to state 14

    expr                           shift and go to state 94
    block                          shift and go to state 96
    while_block                    shift and go to state 11
    if_block                       shift and go to state 12

state 85

    (29) expr -> ID = ZEROS ( INTNUM . )

    )               shift and go to state 97


state 86

    (30) expr -> ID = ONES ( INTNUM . )

    )               shift and go to state 98


state 87

    (31) expr -> ID = EYE ( INTNUM . )

    )               shift and go to state 99


state 88

    (19) expr -> ID [ INTNUM ] = . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 100

state 89

    (20) expr -> ID [ INTNUM ] PLUSASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 101

state 90

    (21) expr -> ID [ INTNUM ] MINASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 102

state 91

    (22) expr -> ID [ INTNUM ] MULTASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 103

state 92

    (23) expr -> ID [ INTNUM ] DIVASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 104

state 93

    (24) expr -> ID [ INTNUM , INTNUM . ] = expr
    (25) expr -> ID [ INTNUM , INTNUM . ] PLUSASSIGN expr
    (26) expr -> ID [ INTNUM , INTNUM . ] MINASSIGN expr
    (27) expr -> ID [ INTNUM , INTNUM . ] MULTASSIGN expr
    (28) expr -> ID [ INTNUM , INTNUM . ] DIVASSIGN expr

    ]               shift and go to state 105


state 94

    (46) block -> expr . ;
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               shift and go to state 106
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26
    EQ              shift and go to state 27
    NEQ             shift and go to state 28
    GTEQ            shift and go to state 29
    LTEQ            shift and go to state 30
    >               shift and go to state 31
    <               shift and go to state 32


state 95

    (51) while_block -> WHILE ( expr ) block .

    INTNUM          reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    FLOATNUM        reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    ID              reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    (               reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    -               reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    [               reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    {               reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    WHILE           reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    IF              reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    $end            reduce using rule 51 (while_block -> WHILE ( expr ) block .)
    }               reduce using rule 51 (while_block -> WHILE ( expr ) block .)


state 96

    (52) if_block -> IF ( expr ) block .

    INTNUM          reduce using rule 52 (if_block -> IF ( expr ) block .)
    FLOATNUM        reduce using rule 52 (if_block -> IF ( expr ) block .)
    ID              reduce using rule 52 (if_block -> IF ( expr ) block .)
    (               reduce using rule 52 (if_block -> IF ( expr ) block .)
    -               reduce using rule 52 (if_block -> IF ( expr ) block .)
    [               reduce using rule 52 (if_block -> IF ( expr ) block .)
    {               reduce using rule 52 (if_block -> IF ( expr ) block .)
    WHILE           reduce using rule 52 (if_block -> IF ( expr ) block .)
    IF              reduce using rule 52 (if_block -> IF ( expr ) block .)
    $end            reduce using rule 52 (if_block -> IF ( expr ) block .)
    }               reduce using rule 52 (if_block -> IF ( expr ) block .)


state 97

    (29) expr -> ID = ZEROS ( INTNUM ) .

    ;               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    '               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    +               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    -               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    *               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    /               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    MPLUS           reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    MMINUS          reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    MMLTP           reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    MDIV            reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    EQ              reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    NEQ             reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    GTEQ            reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    LTEQ            reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    >               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    <               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    )               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    ,               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)
    ]               reduce using rule 29 (expr -> ID = ZEROS ( INTNUM ) .)


state 98

    (30) expr -> ID = ONES ( INTNUM ) .

    ;               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    '               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    +               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    -               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    *               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    /               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    MPLUS           reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    MMINUS          reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    MMLTP           reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    MDIV            reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    EQ              reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    NEQ             reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    GTEQ            reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    LTEQ            reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    >               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    <               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    )               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    ,               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)
    ]               reduce using rule 30 (expr -> ID = ONES ( INTNUM ) .)


state 99

    (31) expr -> ID = EYE ( INTNUM ) .

    ;               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    '               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    +               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    -               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    *               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    /               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    MPLUS           reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    MMINUS          reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    MMLTP           reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    MDIV            reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    EQ              reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    NEQ             reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    GTEQ            reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    LTEQ            reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    >               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    <               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    )               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    ,               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)
    ]               reduce using rule 31 (expr -> ID = EYE ( INTNUM ) .)


state 100

    (19) expr -> ID [ INTNUM ] = expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    EQ              reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    NEQ             reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    GTEQ            reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    LTEQ            reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    >               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    <               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    )               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    ,               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    ]               reduce using rule 19 (expr -> ID [ INTNUM ] = expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! +               [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! -               [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! *               [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! /               [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! MPLUS           [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! MMINUS          [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! MMLTP           [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! MDIV            [ reduce using rule 19 (expr -> ID [ INTNUM ] = expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 101

    (20) expr -> ID [ INTNUM ] PLUSASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    EQ              reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    NEQ             reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    GTEQ            reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    LTEQ            reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    >               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    <               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    )               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    ,               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    ]               reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! +               [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! -               [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! *               [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! /               [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! MDIV            [ reduce using rule 20 (expr -> ID [ INTNUM ] PLUSASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 102

    (21) expr -> ID [ INTNUM ] MINASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    EQ              reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    NEQ             reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    GTEQ            reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    LTEQ            reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    >               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    <               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    )               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    ,               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    ]               reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! +               [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! -               [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! *               [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! /               [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! MDIV            [ reduce using rule 21 (expr -> ID [ INTNUM ] MINASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 103

    (22) expr -> ID [ INTNUM ] MULTASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    EQ              reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    NEQ             reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    GTEQ            reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    LTEQ            reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    >               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    <               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    )               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    ,               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    ]               reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! +               [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! -               [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! *               [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! /               [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! MDIV            [ reduce using rule 22 (expr -> ID [ INTNUM ] MULTASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 104

    (23) expr -> ID [ INTNUM ] DIVASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    EQ              reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    NEQ             reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    GTEQ            reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    LTEQ            reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    >               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    <               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    )               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    ,               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    ]               reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! +               [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! -               [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! *               [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! /               [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! MDIV            [ reduce using rule 23 (expr -> ID [ INTNUM ] DIVASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 105

    (24) expr -> ID [ INTNUM , INTNUM ] . = expr
    (25) expr -> ID [ INTNUM , INTNUM ] . PLUSASSIGN expr
    (26) expr -> ID [ INTNUM , INTNUM ] . MINASSIGN expr
    (27) expr -> ID [ INTNUM , INTNUM ] . MULTASSIGN expr
    (28) expr -> ID [ INTNUM , INTNUM ] . DIVASSIGN expr

    =               shift and go to state 107
    PLUSASSIGN      shift and go to state 108
    MINASSIGN       shift and go to state 109
    MULTASSIGN      shift and go to state 110
    DIVASSIGN       shift and go to state 111


state 106

    (46) block -> expr ; .

    INTNUM          reduce using rule 46 (block -> expr ; .)
    FLOATNUM        reduce using rule 46 (block -> expr ; .)
    ID              reduce using rule 46 (block -> expr ; .)
    (               reduce using rule 46 (block -> expr ; .)
    -               reduce using rule 46 (block -> expr ; .)
    [               reduce using rule 46 (block -> expr ; .)
    {               reduce using rule 46 (block -> expr ; .)
    WHILE           reduce using rule 46 (block -> expr ; .)
    IF              reduce using rule 46 (block -> expr ; .)
    $end            reduce using rule 46 (block -> expr ; .)
    }               reduce using rule 46 (block -> expr ; .)


state 107

    (24) expr -> ID [ INTNUM , INTNUM ] = . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 112

state 108

    (25) expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 113

state 109

    (26) expr -> ID [ INTNUM , INTNUM ] MINASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 114

state 110

    (27) expr -> ID [ INTNUM , INTNUM ] MULTASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 115

state 111

    (28) expr -> ID [ INTNUM , INTNUM ] DIVASSIGN . expr
    (5) expr -> . INTNUM
    (6) expr -> . FLOATNUM
    (7) expr -> . ID
    (8) expr -> . ( expr )
    (9) expr -> . - expr
    (10) expr -> . expr '
    (13) expr -> . [ array_interior ]
    (14) expr -> . ID = expr
    (15) expr -> . ID PLUSASSIGN expr
    (16) expr -> . ID MINASSIGN expr
    (17) expr -> . ID MULTASSIGN expr
    (18) expr -> . ID DIVASSIGN expr
    (19) expr -> . ID [ INTNUM ] = expr
    (20) expr -> . ID [ INTNUM ] PLUSASSIGN expr
    (21) expr -> . ID [ INTNUM ] MINASSIGN expr
    (22) expr -> . ID [ INTNUM ] MULTASSIGN expr
    (23) expr -> . ID [ INTNUM ] DIVASSIGN expr
    (24) expr -> . ID [ INTNUM , INTNUM ] = expr
    (25) expr -> . ID [ INTNUM , INTNUM ] PLUSASSIGN expr
    (26) expr -> . ID [ INTNUM , INTNUM ] MINASSIGN expr
    (27) expr -> . ID [ INTNUM , INTNUM ] MULTASSIGN expr
    (28) expr -> . ID [ INTNUM , INTNUM ] DIVASSIGN expr
    (29) expr -> . ID = ZEROS ( INTNUM )
    (30) expr -> . ID = ONES ( INTNUM )
    (31) expr -> . ID = EYE ( INTNUM )
    (32) expr -> . expr + expr
    (33) expr -> . expr - expr
    (34) expr -> . expr * expr
    (35) expr -> . expr / expr
    (36) expr -> . expr MPLUS expr
    (37) expr -> . expr MMINUS expr
    (38) expr -> . expr MMLTP expr
    (39) expr -> . expr MDIV expr
    (40) expr -> . expr EQ expr
    (41) expr -> . expr NEQ expr
    (42) expr -> . expr GTEQ expr
    (43) expr -> . expr LTEQ expr
    (44) expr -> . expr > expr
    (45) expr -> . expr < expr

    INTNUM          shift and go to state 4
    FLOATNUM        shift and go to state 5
    ID              shift and go to state 6
    (               shift and go to state 7
    -               shift and go to state 8
    [               shift and go to state 9

    expr                           shift and go to state 116

state 112

    (24) expr -> ID [ INTNUM , INTNUM ] = expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    EQ              reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    NEQ             reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    GTEQ            reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    LTEQ            reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    >               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    <               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    )               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    ,               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    ]               reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! +               [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! -               [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! *               [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! /               [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! MPLUS           [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! MMINUS          [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! MMLTP           [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! MDIV            [ reduce using rule 24 (expr -> ID [ INTNUM , INTNUM ] = expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 113

    (25) expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    EQ              reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    NEQ             reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    GTEQ            reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    LTEQ            reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    >               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    <               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    )               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    ,               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    ]               reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! +               [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! -               [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! *               [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! /               [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! MDIV            [ reduce using rule 25 (expr -> ID [ INTNUM , INTNUM ] PLUSASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 114

    (26) expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    EQ              reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    NEQ             reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    GTEQ            reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    LTEQ            reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    >               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    <               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    )               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    ,               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    ]               reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! +               [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! -               [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! *               [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! /               [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! MDIV            [ reduce using rule 26 (expr -> ID [ INTNUM , INTNUM ] MINASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 115

    (27) expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    EQ              reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    NEQ             reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    GTEQ            reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    LTEQ            reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    >               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    <               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    )               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    ,               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    ]               reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! +               [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! -               [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! *               [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! /               [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! MDIV            [ reduce using rule 27 (expr -> ID [ INTNUM , INTNUM ] MULTASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]


state 116

    (28) expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .
    (10) expr -> expr . '
    (32) expr -> expr . + expr
    (33) expr -> expr . - expr
    (34) expr -> expr . * expr
    (35) expr -> expr . / expr
    (36) expr -> expr . MPLUS expr
    (37) expr -> expr . MMINUS expr
    (38) expr -> expr . MMLTP expr
    (39) expr -> expr . MDIV expr
    (40) expr -> expr . EQ expr
    (41) expr -> expr . NEQ expr
    (42) expr -> expr . GTEQ expr
    (43) expr -> expr . LTEQ expr
    (44) expr -> expr . > expr
    (45) expr -> expr . < expr

    ;               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    EQ              reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    NEQ             reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    GTEQ            reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    LTEQ            reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    >               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    <               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    )               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    ,               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    ]               reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .)
    '               shift and go to state 18
    +               shift and go to state 19
    -               shift and go to state 20
    *               shift and go to state 21
    /               shift and go to state 22
    MPLUS           shift and go to state 23
    MMINUS          shift and go to state 24
    MMLTP           shift and go to state 25
    MDIV            shift and go to state 26

  ! '               [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! +               [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! -               [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! *               [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! /               [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! MDIV            [ reduce using rule 28 (expr -> ID [ INTNUM , INTNUM ] DIVASSIGN expr .) ]
  ! EQ              [ shift and go to state 27 ]
  ! NEQ             [ shift and go to state 28 ]
  ! GTEQ            [ shift and go to state 29 ]
  ! LTEQ            [ shift and go to state 30 ]
  ! >               [ shift and go to state 31 ]
  ! <               [ shift and go to state 32 ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ' in state 56 resolved as shift
WARNING: shift/reduce conflict for + in state 56 resolved as shift
WARNING: shift/reduce conflict for - in state 56 resolved as shift
WARNING: shift/reduce conflict for * in state 56 resolved as shift
WARNING: shift/reduce conflict for / in state 56 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 56 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 56 resolved as shift
WARNING: shift/reduce conflict for EQ in state 56 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 56 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 56 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 56 resolved as shift
WARNING: shift/reduce conflict for > in state 56 resolved as shift
WARNING: shift/reduce conflict for < in state 56 resolved as shift
WARNING: shift/reduce conflict for ' in state 57 resolved as shift
WARNING: shift/reduce conflict for + in state 57 resolved as shift
WARNING: shift/reduce conflict for - in state 57 resolved as shift
WARNING: shift/reduce conflict for * in state 57 resolved as shift
WARNING: shift/reduce conflict for / in state 57 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 57 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 57 resolved as shift
WARNING: shift/reduce conflict for EQ in state 57 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 57 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 57 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 57 resolved as shift
WARNING: shift/reduce conflict for > in state 57 resolved as shift
WARNING: shift/reduce conflict for < in state 57 resolved as shift
WARNING: shift/reduce conflict for ' in state 58 resolved as shift
WARNING: shift/reduce conflict for + in state 58 resolved as shift
WARNING: shift/reduce conflict for - in state 58 resolved as shift
WARNING: shift/reduce conflict for * in state 58 resolved as shift
WARNING: shift/reduce conflict for / in state 58 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 58 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 58 resolved as shift
WARNING: shift/reduce conflict for EQ in state 58 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 58 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 58 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 58 resolved as shift
WARNING: shift/reduce conflict for > in state 58 resolved as shift
WARNING: shift/reduce conflict for < in state 58 resolved as shift
WARNING: shift/reduce conflict for ' in state 59 resolved as shift
WARNING: shift/reduce conflict for + in state 59 resolved as shift
WARNING: shift/reduce conflict for - in state 59 resolved as shift
WARNING: shift/reduce conflict for * in state 59 resolved as shift
WARNING: shift/reduce conflict for / in state 59 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 59 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 59 resolved as shift
WARNING: shift/reduce conflict for EQ in state 59 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 59 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 59 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 59 resolved as shift
WARNING: shift/reduce conflict for > in state 59 resolved as shift
WARNING: shift/reduce conflict for < in state 59 resolved as shift
WARNING: shift/reduce conflict for ' in state 60 resolved as shift
WARNING: shift/reduce conflict for + in state 60 resolved as shift
WARNING: shift/reduce conflict for - in state 60 resolved as shift
WARNING: shift/reduce conflict for * in state 60 resolved as shift
WARNING: shift/reduce conflict for / in state 60 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 60 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 60 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 60 resolved as shift
WARNING: shift/reduce conflict for EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 60 resolved as shift
WARNING: shift/reduce conflict for > in state 60 resolved as shift
WARNING: shift/reduce conflict for < in state 60 resolved as shift
WARNING: shift/reduce conflict for ' in state 61 resolved as shift
WARNING: shift/reduce conflict for + in state 61 resolved as shift
WARNING: shift/reduce conflict for - in state 61 resolved as shift
WARNING: shift/reduce conflict for * in state 61 resolved as shift
WARNING: shift/reduce conflict for / in state 61 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MMLTP in state 61 resolved as shift
WARNING: shift/reduce conflict for MDIV in state 61 resolved as shift
WARNING: shift/reduce conflict for EQ in state 61 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for GTEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for LTEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for > in state 61 resolved as shift
WARNING: shift/reduce conflict for < in state 61 resolved as shift
WARNING: reduce/reduce conflict in state 17 resolved using rule (start -> expr ;)
WARNING: rejected rule (block -> expr ;) in state 17
WARNING: reduce/reduce conflict in state 47 resolved using rule (start -> start expr ;)
WARNING: rejected rule (block -> expr ;) in state 47
