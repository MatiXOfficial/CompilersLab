Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> root
Rule 1     root -> start
Rule 2     start -> struct
Rule 3     start -> start struct
Rule 4     block -> { block_interior }
Rule 5     struct -> expr ;
Rule 6     struct -> instruction ;
Rule 7     struct -> cond_expr
Rule 8     struct -> block
Rule 9     block_interior -> struct
Rule 10    block_interior -> block_interior struct
Rule 11    loop_block -> { loop_block_interior }
Rule 12    loop_struct -> loop_single_stmt ;
Rule 13    loop_struct -> loop_cond_expr
Rule 14    loop_struct -> loop_block
Rule 15    loop_block_interior -> loop_block_interior expr ;
Rule 16    loop_block_interior -> loop_block_interior loop_instruction ;
Rule 17    loop_block_interior -> loop_block_interior loop_cond_expr
Rule 18    loop_block_interior -> expr ;
Rule 19    loop_block_interior -> loop_instruction ;
Rule 20    loop_block_interior -> loop_cond_expr
Rule 21    loop_single_stmt -> loop_instruction
Rule 22    loop_single_stmt -> assignment
Rule 23    expr -> INTNUM
Rule 24    expr -> FLOATNUM
Rule 25    expr -> STRING
Rule 26    expr -> ZEROS ( expr )
Rule 27    expr -> ONES ( expr )
Rule 28    expr -> EYE ( expr )
Rule 29    expr -> lvalue
Rule 30    expr -> ( expr )
Rule 31    expr -> - expr
Rule 32    expr -> expr '
Rule 33    array_interior -> array_interior , expr
Rule 34    array_interior -> expr
Rule 35    range -> expr : expr
Rule 36    expr -> [ array_interior ]
Rule 37    lvalue -> ID
Rule 38    lvalue -> ID [ array_interior ]
Rule 39    lvalue -> ID [ range ]
Rule 40    assignment -> lvalue = expr
Rule 41    assignment -> lvalue PLUSASSIGN expr
Rule 42    assignment -> lvalue MINASSIGN expr
Rule 43    assignment -> lvalue MULTASSIGN expr
Rule 44    assignment -> lvalue DIVASSIGN expr
Rule 45    expr -> assignment
Rule 46    expr -> expr + expr
Rule 47    expr -> expr - expr
Rule 48    expr -> expr * expr
Rule 49    expr -> expr / expr
Rule 50    expr -> expr MPLUS expr
Rule 51    expr -> expr MMINUS expr
Rule 52    expr -> expr MMLTP expr
Rule 53    expr -> expr MDIV expr
Rule 54    expr -> expr EQ expr
Rule 55    expr -> expr NEQ expr
Rule 56    expr -> expr GTEQ expr
Rule 57    expr -> expr LTEQ expr
Rule 58    expr -> expr > expr
Rule 59    expr -> expr < expr
Rule 60    cond_expr -> cond_if
Rule 61    cond_expr -> cond_while
Rule 62    cond_expr -> cond_for
Rule 63    cond_if -> IF ( expr ) struct
Rule 64    cond_if -> IF ( expr ) struct ELSE struct
Rule 65    loop_cond_expr -> loop_cond_if
Rule 66    loop_cond_expr -> cond_while
Rule 67    loop_cond_expr -> cond_for
Rule 68    loop_cond_if -> IF ( expr ) loop_struct
Rule 69    loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct
Rule 70    cond_while -> WHILE ( expr ) loop_struct
Rule 71    cond_for -> FOR lvalue = range loop_struct
Rule 72    instruction -> RETURN expr
Rule 73    instruction -> PRINT array_interior
Rule 74    loop_instruction -> BREAK
Rule 75    loop_instruction -> CONTINUE
Rule 76    loop_instruction -> instruction

Terminals, with rules where they appear

'                    : 32
(                    : 26 27 28 30 63 64 68 69 70
)                    : 26 27 28 30 63 64 68 69 70
*                    : 48
+                    : 46
,                    : 33
-                    : 31 47
/                    : 49
:                    : 35
;                    : 5 6 12 15 16 18 19
<                    : 59
=                    : 40 71
>                    : 58
BREAK                : 74
CONTINUE             : 75
DIVASSIGN            : 44
ELSE                 : 64 69
EQ                   : 54
EYE                  : 28
FLOATNUM             : 24
FOR                  : 71
GTEQ                 : 56
ID                   : 37 38 39
IF                   : 63 64 68 69
INTNUM               : 23
LTEQ                 : 57
MDIV                 : 53
MINASSIGN            : 42
MMINUS               : 51
MMLTP                : 52
MPLUS                : 50
MULTASSIGN           : 43
NEQ                  : 55
ONES                 : 27
PLUSASSIGN           : 41
PRINT                : 73
RETURN               : 72
STRING               : 25
WHILE                : 70
ZEROS                : 26
[                    : 36 38 39
]                    : 36 38 39
error                : 
{                    : 4 11
}                    : 4 11

Nonterminals, with rules where they appear

array_interior       : 33 36 38 73
assignment           : 22 45
block                : 8
block_interior       : 4 10
cond_expr            : 7
cond_for             : 62 67
cond_if              : 60
cond_while           : 61 66
expr                 : 5 15 18 26 27 28 30 31 32 33 34 35 35 40 41 42 43 44 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 63 64 68 69 70 72
instruction          : 6 76
loop_block           : 14
loop_block_interior  : 11 15 16 17
loop_cond_expr       : 13 17 20
loop_cond_if         : 65
loop_instruction     : 16 19 21
loop_single_stmt     : 12
loop_struct          : 68 69 69 70 71
lvalue               : 29 40 41 42 43 44 71
range                : 39 71
root                 : 0
start                : 1 3
struct               : 2 3 9 10 63 64 64

Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . start
    (2) start -> . struct
    (3) start -> . start struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    root                           shift and go to state 1
    start                          shift and go to state 2
    struct                         shift and go to state 3
    expr                           shift and go to state 4
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 1

    (0) S' -> root .



state 2

    (1) root -> start .
    (3) start -> start . struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    $end            reduce using rule 1 (root -> start .)
    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    struct                         shift and go to state 29
    expr                           shift and go to state 4
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 3

    (2) start -> struct .

    INTNUM          reduce using rule 2 (start -> struct .)
    FLOATNUM        reduce using rule 2 (start -> struct .)
    STRING          reduce using rule 2 (start -> struct .)
    ZEROS           reduce using rule 2 (start -> struct .)
    ONES            reduce using rule 2 (start -> struct .)
    EYE             reduce using rule 2 (start -> struct .)
    (               reduce using rule 2 (start -> struct .)
    -               reduce using rule 2 (start -> struct .)
    [               reduce using rule 2 (start -> struct .)
    RETURN          reduce using rule 2 (start -> struct .)
    PRINT           reduce using rule 2 (start -> struct .)
    {               reduce using rule 2 (start -> struct .)
    ID              reduce using rule 2 (start -> struct .)
    IF              reduce using rule 2 (start -> struct .)
    WHILE           reduce using rule 2 (start -> struct .)
    FOR             reduce using rule 2 (start -> struct .)
    $end            reduce using rule 2 (start -> struct .)


state 4

    (5) struct -> expr . ;
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               shift and go to state 30
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 5

    (6) struct -> instruction . ;

    ;               shift and go to state 46


state 6

    (7) struct -> cond_expr .

    INTNUM          reduce using rule 7 (struct -> cond_expr .)
    FLOATNUM        reduce using rule 7 (struct -> cond_expr .)
    STRING          reduce using rule 7 (struct -> cond_expr .)
    ZEROS           reduce using rule 7 (struct -> cond_expr .)
    ONES            reduce using rule 7 (struct -> cond_expr .)
    EYE             reduce using rule 7 (struct -> cond_expr .)
    (               reduce using rule 7 (struct -> cond_expr .)
    -               reduce using rule 7 (struct -> cond_expr .)
    [               reduce using rule 7 (struct -> cond_expr .)
    RETURN          reduce using rule 7 (struct -> cond_expr .)
    PRINT           reduce using rule 7 (struct -> cond_expr .)
    {               reduce using rule 7 (struct -> cond_expr .)
    ID              reduce using rule 7 (struct -> cond_expr .)
    IF              reduce using rule 7 (struct -> cond_expr .)
    WHILE           reduce using rule 7 (struct -> cond_expr .)
    FOR             reduce using rule 7 (struct -> cond_expr .)
    $end            reduce using rule 7 (struct -> cond_expr .)
    }               reduce using rule 7 (struct -> cond_expr .)
    ELSE            reduce using rule 7 (struct -> cond_expr .)


state 7

    (8) struct -> block .

    INTNUM          reduce using rule 8 (struct -> block .)
    FLOATNUM        reduce using rule 8 (struct -> block .)
    STRING          reduce using rule 8 (struct -> block .)
    ZEROS           reduce using rule 8 (struct -> block .)
    ONES            reduce using rule 8 (struct -> block .)
    EYE             reduce using rule 8 (struct -> block .)
    (               reduce using rule 8 (struct -> block .)
    -               reduce using rule 8 (struct -> block .)
    [               reduce using rule 8 (struct -> block .)
    RETURN          reduce using rule 8 (struct -> block .)
    PRINT           reduce using rule 8 (struct -> block .)
    {               reduce using rule 8 (struct -> block .)
    ID              reduce using rule 8 (struct -> block .)
    IF              reduce using rule 8 (struct -> block .)
    WHILE           reduce using rule 8 (struct -> block .)
    FOR             reduce using rule 8 (struct -> block .)
    $end            reduce using rule 8 (struct -> block .)
    }               reduce using rule 8 (struct -> block .)
    ELSE            reduce using rule 8 (struct -> block .)


state 8

    (23) expr -> INTNUM .

    ;               reduce using rule 23 (expr -> INTNUM .)
    '               reduce using rule 23 (expr -> INTNUM .)
    +               reduce using rule 23 (expr -> INTNUM .)
    -               reduce using rule 23 (expr -> INTNUM .)
    *               reduce using rule 23 (expr -> INTNUM .)
    /               reduce using rule 23 (expr -> INTNUM .)
    MPLUS           reduce using rule 23 (expr -> INTNUM .)
    MMINUS          reduce using rule 23 (expr -> INTNUM .)
    MMLTP           reduce using rule 23 (expr -> INTNUM .)
    MDIV            reduce using rule 23 (expr -> INTNUM .)
    EQ              reduce using rule 23 (expr -> INTNUM .)
    NEQ             reduce using rule 23 (expr -> INTNUM .)
    GTEQ            reduce using rule 23 (expr -> INTNUM .)
    LTEQ            reduce using rule 23 (expr -> INTNUM .)
    >               reduce using rule 23 (expr -> INTNUM .)
    <               reduce using rule 23 (expr -> INTNUM .)
    )               reduce using rule 23 (expr -> INTNUM .)
    ]               reduce using rule 23 (expr -> INTNUM .)
    ,               reduce using rule 23 (expr -> INTNUM .)
    :               reduce using rule 23 (expr -> INTNUM .)
    {               reduce using rule 23 (expr -> INTNUM .)
    BREAK           reduce using rule 23 (expr -> INTNUM .)
    CONTINUE        reduce using rule 23 (expr -> INTNUM .)
    IF              reduce using rule 23 (expr -> INTNUM .)
    WHILE           reduce using rule 23 (expr -> INTNUM .)
    FOR             reduce using rule 23 (expr -> INTNUM .)
    RETURN          reduce using rule 23 (expr -> INTNUM .)
    PRINT           reduce using rule 23 (expr -> INTNUM .)
    ID              reduce using rule 23 (expr -> INTNUM .)


state 9

    (24) expr -> FLOATNUM .

    ;               reduce using rule 24 (expr -> FLOATNUM .)
    '               reduce using rule 24 (expr -> FLOATNUM .)
    +               reduce using rule 24 (expr -> FLOATNUM .)
    -               reduce using rule 24 (expr -> FLOATNUM .)
    *               reduce using rule 24 (expr -> FLOATNUM .)
    /               reduce using rule 24 (expr -> FLOATNUM .)
    MPLUS           reduce using rule 24 (expr -> FLOATNUM .)
    MMINUS          reduce using rule 24 (expr -> FLOATNUM .)
    MMLTP           reduce using rule 24 (expr -> FLOATNUM .)
    MDIV            reduce using rule 24 (expr -> FLOATNUM .)
    EQ              reduce using rule 24 (expr -> FLOATNUM .)
    NEQ             reduce using rule 24 (expr -> FLOATNUM .)
    GTEQ            reduce using rule 24 (expr -> FLOATNUM .)
    LTEQ            reduce using rule 24 (expr -> FLOATNUM .)
    >               reduce using rule 24 (expr -> FLOATNUM .)
    <               reduce using rule 24 (expr -> FLOATNUM .)
    )               reduce using rule 24 (expr -> FLOATNUM .)
    ]               reduce using rule 24 (expr -> FLOATNUM .)
    ,               reduce using rule 24 (expr -> FLOATNUM .)
    :               reduce using rule 24 (expr -> FLOATNUM .)
    {               reduce using rule 24 (expr -> FLOATNUM .)
    BREAK           reduce using rule 24 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 24 (expr -> FLOATNUM .)
    IF              reduce using rule 24 (expr -> FLOATNUM .)
    WHILE           reduce using rule 24 (expr -> FLOATNUM .)
    FOR             reduce using rule 24 (expr -> FLOATNUM .)
    RETURN          reduce using rule 24 (expr -> FLOATNUM .)
    PRINT           reduce using rule 24 (expr -> FLOATNUM .)
    ID              reduce using rule 24 (expr -> FLOATNUM .)


state 10

    (25) expr -> STRING .

    ;               reduce using rule 25 (expr -> STRING .)
    '               reduce using rule 25 (expr -> STRING .)
    +               reduce using rule 25 (expr -> STRING .)
    -               reduce using rule 25 (expr -> STRING .)
    *               reduce using rule 25 (expr -> STRING .)
    /               reduce using rule 25 (expr -> STRING .)
    MPLUS           reduce using rule 25 (expr -> STRING .)
    MMINUS          reduce using rule 25 (expr -> STRING .)
    MMLTP           reduce using rule 25 (expr -> STRING .)
    MDIV            reduce using rule 25 (expr -> STRING .)
    EQ              reduce using rule 25 (expr -> STRING .)
    NEQ             reduce using rule 25 (expr -> STRING .)
    GTEQ            reduce using rule 25 (expr -> STRING .)
    LTEQ            reduce using rule 25 (expr -> STRING .)
    >               reduce using rule 25 (expr -> STRING .)
    <               reduce using rule 25 (expr -> STRING .)
    )               reduce using rule 25 (expr -> STRING .)
    ]               reduce using rule 25 (expr -> STRING .)
    ,               reduce using rule 25 (expr -> STRING .)
    :               reduce using rule 25 (expr -> STRING .)
    {               reduce using rule 25 (expr -> STRING .)
    BREAK           reduce using rule 25 (expr -> STRING .)
    CONTINUE        reduce using rule 25 (expr -> STRING .)
    IF              reduce using rule 25 (expr -> STRING .)
    WHILE           reduce using rule 25 (expr -> STRING .)
    FOR             reduce using rule 25 (expr -> STRING .)
    RETURN          reduce using rule 25 (expr -> STRING .)
    PRINT           reduce using rule 25 (expr -> STRING .)
    ID              reduce using rule 25 (expr -> STRING .)


state 11

    (26) expr -> ZEROS . ( expr )

    (               shift and go to state 47


state 12

    (30) expr -> ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 48
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 13

    (27) expr -> ONES . ( expr )

    (               shift and go to state 49


state 14

    (28) expr -> EYE . ( expr )

    (               shift and go to state 50


state 15

    (29) expr -> lvalue .
    (40) assignment -> lvalue . = expr
    (41) assignment -> lvalue . PLUSASSIGN expr
    (42) assignment -> lvalue . MINASSIGN expr
    (43) assignment -> lvalue . MULTASSIGN expr
    (44) assignment -> lvalue . DIVASSIGN expr

    ;               reduce using rule 29 (expr -> lvalue .)
    '               reduce using rule 29 (expr -> lvalue .)
    +               reduce using rule 29 (expr -> lvalue .)
    -               reduce using rule 29 (expr -> lvalue .)
    *               reduce using rule 29 (expr -> lvalue .)
    /               reduce using rule 29 (expr -> lvalue .)
    MPLUS           reduce using rule 29 (expr -> lvalue .)
    MMINUS          reduce using rule 29 (expr -> lvalue .)
    MMLTP           reduce using rule 29 (expr -> lvalue .)
    MDIV            reduce using rule 29 (expr -> lvalue .)
    EQ              reduce using rule 29 (expr -> lvalue .)
    NEQ             reduce using rule 29 (expr -> lvalue .)
    GTEQ            reduce using rule 29 (expr -> lvalue .)
    LTEQ            reduce using rule 29 (expr -> lvalue .)
    >               reduce using rule 29 (expr -> lvalue .)
    <               reduce using rule 29 (expr -> lvalue .)
    )               reduce using rule 29 (expr -> lvalue .)
    ]               reduce using rule 29 (expr -> lvalue .)
    ,               reduce using rule 29 (expr -> lvalue .)
    :               reduce using rule 29 (expr -> lvalue .)
    {               reduce using rule 29 (expr -> lvalue .)
    BREAK           reduce using rule 29 (expr -> lvalue .)
    CONTINUE        reduce using rule 29 (expr -> lvalue .)
    IF              reduce using rule 29 (expr -> lvalue .)
    WHILE           reduce using rule 29 (expr -> lvalue .)
    FOR             reduce using rule 29 (expr -> lvalue .)
    RETURN          reduce using rule 29 (expr -> lvalue .)
    PRINT           reduce using rule 29 (expr -> lvalue .)
    ID              reduce using rule 29 (expr -> lvalue .)
    =               shift and go to state 51
    PLUSASSIGN      shift and go to state 52
    MINASSIGN       shift and go to state 53
    MULTASSIGN      shift and go to state 54
    DIVASSIGN       shift and go to state 55


state 16

    (31) expr -> - . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 56
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 17

    (36) expr -> [ . array_interior ]
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    array_interior                 shift and go to state 57
    expr                           shift and go to state 58
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 18

    (45) expr -> assignment .

    ;               reduce using rule 45 (expr -> assignment .)
    '               reduce using rule 45 (expr -> assignment .)
    +               reduce using rule 45 (expr -> assignment .)
    -               reduce using rule 45 (expr -> assignment .)
    *               reduce using rule 45 (expr -> assignment .)
    /               reduce using rule 45 (expr -> assignment .)
    MPLUS           reduce using rule 45 (expr -> assignment .)
    MMINUS          reduce using rule 45 (expr -> assignment .)
    MMLTP           reduce using rule 45 (expr -> assignment .)
    MDIV            reduce using rule 45 (expr -> assignment .)
    EQ              reduce using rule 45 (expr -> assignment .)
    NEQ             reduce using rule 45 (expr -> assignment .)
    GTEQ            reduce using rule 45 (expr -> assignment .)
    LTEQ            reduce using rule 45 (expr -> assignment .)
    >               reduce using rule 45 (expr -> assignment .)
    <               reduce using rule 45 (expr -> assignment .)
    )               reduce using rule 45 (expr -> assignment .)
    ]               reduce using rule 45 (expr -> assignment .)
    ,               reduce using rule 45 (expr -> assignment .)
    :               reduce using rule 45 (expr -> assignment .)
    {               reduce using rule 45 (expr -> assignment .)
    BREAK           reduce using rule 45 (expr -> assignment .)
    CONTINUE        reduce using rule 45 (expr -> assignment .)
    IF              reduce using rule 45 (expr -> assignment .)
    WHILE           reduce using rule 45 (expr -> assignment .)
    FOR             reduce using rule 45 (expr -> assignment .)
    RETURN          reduce using rule 45 (expr -> assignment .)
    PRINT           reduce using rule 45 (expr -> assignment .)
    ID              reduce using rule 45 (expr -> assignment .)


state 19

    (72) instruction -> RETURN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 59
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 20

    (73) instruction -> PRINT . array_interior
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    array_interior                 shift and go to state 60
    expr                           shift and go to state 58
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 21

    (60) cond_expr -> cond_if .

    INTNUM          reduce using rule 60 (cond_expr -> cond_if .)
    FLOATNUM        reduce using rule 60 (cond_expr -> cond_if .)
    STRING          reduce using rule 60 (cond_expr -> cond_if .)
    ZEROS           reduce using rule 60 (cond_expr -> cond_if .)
    ONES            reduce using rule 60 (cond_expr -> cond_if .)
    EYE             reduce using rule 60 (cond_expr -> cond_if .)
    (               reduce using rule 60 (cond_expr -> cond_if .)
    -               reduce using rule 60 (cond_expr -> cond_if .)
    [               reduce using rule 60 (cond_expr -> cond_if .)
    RETURN          reduce using rule 60 (cond_expr -> cond_if .)
    PRINT           reduce using rule 60 (cond_expr -> cond_if .)
    {               reduce using rule 60 (cond_expr -> cond_if .)
    ID              reduce using rule 60 (cond_expr -> cond_if .)
    IF              reduce using rule 60 (cond_expr -> cond_if .)
    WHILE           reduce using rule 60 (cond_expr -> cond_if .)
    FOR             reduce using rule 60 (cond_expr -> cond_if .)
    $end            reduce using rule 60 (cond_expr -> cond_if .)
    }               reduce using rule 60 (cond_expr -> cond_if .)
    ELSE            reduce using rule 60 (cond_expr -> cond_if .)


state 22

    (61) cond_expr -> cond_while .

    INTNUM          reduce using rule 61 (cond_expr -> cond_while .)
    FLOATNUM        reduce using rule 61 (cond_expr -> cond_while .)
    STRING          reduce using rule 61 (cond_expr -> cond_while .)
    ZEROS           reduce using rule 61 (cond_expr -> cond_while .)
    ONES            reduce using rule 61 (cond_expr -> cond_while .)
    EYE             reduce using rule 61 (cond_expr -> cond_while .)
    (               reduce using rule 61 (cond_expr -> cond_while .)
    -               reduce using rule 61 (cond_expr -> cond_while .)
    [               reduce using rule 61 (cond_expr -> cond_while .)
    RETURN          reduce using rule 61 (cond_expr -> cond_while .)
    PRINT           reduce using rule 61 (cond_expr -> cond_while .)
    {               reduce using rule 61 (cond_expr -> cond_while .)
    ID              reduce using rule 61 (cond_expr -> cond_while .)
    IF              reduce using rule 61 (cond_expr -> cond_while .)
    WHILE           reduce using rule 61 (cond_expr -> cond_while .)
    FOR             reduce using rule 61 (cond_expr -> cond_while .)
    $end            reduce using rule 61 (cond_expr -> cond_while .)
    }               reduce using rule 61 (cond_expr -> cond_while .)
    ELSE            reduce using rule 61 (cond_expr -> cond_while .)


state 23

    (62) cond_expr -> cond_for .

    INTNUM          reduce using rule 62 (cond_expr -> cond_for .)
    FLOATNUM        reduce using rule 62 (cond_expr -> cond_for .)
    STRING          reduce using rule 62 (cond_expr -> cond_for .)
    ZEROS           reduce using rule 62 (cond_expr -> cond_for .)
    ONES            reduce using rule 62 (cond_expr -> cond_for .)
    EYE             reduce using rule 62 (cond_expr -> cond_for .)
    (               reduce using rule 62 (cond_expr -> cond_for .)
    -               reduce using rule 62 (cond_expr -> cond_for .)
    [               reduce using rule 62 (cond_expr -> cond_for .)
    RETURN          reduce using rule 62 (cond_expr -> cond_for .)
    PRINT           reduce using rule 62 (cond_expr -> cond_for .)
    {               reduce using rule 62 (cond_expr -> cond_for .)
    ID              reduce using rule 62 (cond_expr -> cond_for .)
    IF              reduce using rule 62 (cond_expr -> cond_for .)
    WHILE           reduce using rule 62 (cond_expr -> cond_for .)
    FOR             reduce using rule 62 (cond_expr -> cond_for .)
    $end            reduce using rule 62 (cond_expr -> cond_for .)
    }               reduce using rule 62 (cond_expr -> cond_for .)
    ELSE            reduce using rule 62 (cond_expr -> cond_for .)


state 24

    (4) block -> { . block_interior }
    (9) block_interior -> . struct
    (10) block_interior -> . block_interior struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    block_interior                 shift and go to state 61
    struct                         shift and go to state 62
    expr                           shift and go to state 4
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 25

    (37) lvalue -> ID .
    (38) lvalue -> ID . [ array_interior ]
    (39) lvalue -> ID . [ range ]

    =               reduce using rule 37 (lvalue -> ID .)
    PLUSASSIGN      reduce using rule 37 (lvalue -> ID .)
    MINASSIGN       reduce using rule 37 (lvalue -> ID .)
    MULTASSIGN      reduce using rule 37 (lvalue -> ID .)
    DIVASSIGN       reduce using rule 37 (lvalue -> ID .)
    ;               reduce using rule 37 (lvalue -> ID .)
    '               reduce using rule 37 (lvalue -> ID .)
    +               reduce using rule 37 (lvalue -> ID .)
    -               reduce using rule 37 (lvalue -> ID .)
    *               reduce using rule 37 (lvalue -> ID .)
    /               reduce using rule 37 (lvalue -> ID .)
    MPLUS           reduce using rule 37 (lvalue -> ID .)
    MMINUS          reduce using rule 37 (lvalue -> ID .)
    MMLTP           reduce using rule 37 (lvalue -> ID .)
    MDIV            reduce using rule 37 (lvalue -> ID .)
    EQ              reduce using rule 37 (lvalue -> ID .)
    NEQ             reduce using rule 37 (lvalue -> ID .)
    GTEQ            reduce using rule 37 (lvalue -> ID .)
    LTEQ            reduce using rule 37 (lvalue -> ID .)
    >               reduce using rule 37 (lvalue -> ID .)
    <               reduce using rule 37 (lvalue -> ID .)
    )               reduce using rule 37 (lvalue -> ID .)
    ]               reduce using rule 37 (lvalue -> ID .)
    ,               reduce using rule 37 (lvalue -> ID .)
    :               reduce using rule 37 (lvalue -> ID .)
    {               reduce using rule 37 (lvalue -> ID .)
    BREAK           reduce using rule 37 (lvalue -> ID .)
    CONTINUE        reduce using rule 37 (lvalue -> ID .)
    IF              reduce using rule 37 (lvalue -> ID .)
    WHILE           reduce using rule 37 (lvalue -> ID .)
    FOR             reduce using rule 37 (lvalue -> ID .)
    RETURN          reduce using rule 37 (lvalue -> ID .)
    PRINT           reduce using rule 37 (lvalue -> ID .)
    ID              reduce using rule 37 (lvalue -> ID .)
    [               shift and go to state 63


state 26

    (63) cond_if -> IF . ( expr ) struct
    (64) cond_if -> IF . ( expr ) struct ELSE struct

    (               shift and go to state 64


state 27

    (70) cond_while -> WHILE . ( expr ) loop_struct

    (               shift and go to state 65


state 28

    (71) cond_for -> FOR . lvalue = range loop_struct
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]

    ID              shift and go to state 25

    lvalue                         shift and go to state 66

state 29

    (3) start -> start struct .

    INTNUM          reduce using rule 3 (start -> start struct .)
    FLOATNUM        reduce using rule 3 (start -> start struct .)
    STRING          reduce using rule 3 (start -> start struct .)
    ZEROS           reduce using rule 3 (start -> start struct .)
    ONES            reduce using rule 3 (start -> start struct .)
    EYE             reduce using rule 3 (start -> start struct .)
    (               reduce using rule 3 (start -> start struct .)
    -               reduce using rule 3 (start -> start struct .)
    [               reduce using rule 3 (start -> start struct .)
    RETURN          reduce using rule 3 (start -> start struct .)
    PRINT           reduce using rule 3 (start -> start struct .)
    {               reduce using rule 3 (start -> start struct .)
    ID              reduce using rule 3 (start -> start struct .)
    IF              reduce using rule 3 (start -> start struct .)
    WHILE           reduce using rule 3 (start -> start struct .)
    FOR             reduce using rule 3 (start -> start struct .)
    $end            reduce using rule 3 (start -> start struct .)


state 30

    (5) struct -> expr ; .

    INTNUM          reduce using rule 5 (struct -> expr ; .)
    FLOATNUM        reduce using rule 5 (struct -> expr ; .)
    STRING          reduce using rule 5 (struct -> expr ; .)
    ZEROS           reduce using rule 5 (struct -> expr ; .)
    ONES            reduce using rule 5 (struct -> expr ; .)
    EYE             reduce using rule 5 (struct -> expr ; .)
    (               reduce using rule 5 (struct -> expr ; .)
    -               reduce using rule 5 (struct -> expr ; .)
    [               reduce using rule 5 (struct -> expr ; .)
    RETURN          reduce using rule 5 (struct -> expr ; .)
    PRINT           reduce using rule 5 (struct -> expr ; .)
    {               reduce using rule 5 (struct -> expr ; .)
    ID              reduce using rule 5 (struct -> expr ; .)
    IF              reduce using rule 5 (struct -> expr ; .)
    WHILE           reduce using rule 5 (struct -> expr ; .)
    FOR             reduce using rule 5 (struct -> expr ; .)
    $end            reduce using rule 5 (struct -> expr ; .)
    }               reduce using rule 5 (struct -> expr ; .)
    ELSE            reduce using rule 5 (struct -> expr ; .)


state 31

    (32) expr -> expr ' .

    ;               reduce using rule 32 (expr -> expr ' .)
    '               reduce using rule 32 (expr -> expr ' .)
    +               reduce using rule 32 (expr -> expr ' .)
    -               reduce using rule 32 (expr -> expr ' .)
    *               reduce using rule 32 (expr -> expr ' .)
    /               reduce using rule 32 (expr -> expr ' .)
    MPLUS           reduce using rule 32 (expr -> expr ' .)
    MMINUS          reduce using rule 32 (expr -> expr ' .)
    MMLTP           reduce using rule 32 (expr -> expr ' .)
    MDIV            reduce using rule 32 (expr -> expr ' .)
    EQ              reduce using rule 32 (expr -> expr ' .)
    NEQ             reduce using rule 32 (expr -> expr ' .)
    GTEQ            reduce using rule 32 (expr -> expr ' .)
    LTEQ            reduce using rule 32 (expr -> expr ' .)
    >               reduce using rule 32 (expr -> expr ' .)
    <               reduce using rule 32 (expr -> expr ' .)
    )               reduce using rule 32 (expr -> expr ' .)
    ]               reduce using rule 32 (expr -> expr ' .)
    ,               reduce using rule 32 (expr -> expr ' .)
    :               reduce using rule 32 (expr -> expr ' .)
    {               reduce using rule 32 (expr -> expr ' .)
    BREAK           reduce using rule 32 (expr -> expr ' .)
    CONTINUE        reduce using rule 32 (expr -> expr ' .)
    IF              reduce using rule 32 (expr -> expr ' .)
    WHILE           reduce using rule 32 (expr -> expr ' .)
    FOR             reduce using rule 32 (expr -> expr ' .)
    RETURN          reduce using rule 32 (expr -> expr ' .)
    PRINT           reduce using rule 32 (expr -> expr ' .)
    ID              reduce using rule 32 (expr -> expr ' .)


state 32

    (46) expr -> expr + . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 67
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 33

    (47) expr -> expr - . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 68
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 34

    (48) expr -> expr * . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 69
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 35

    (49) expr -> expr / . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 70
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 36

    (50) expr -> expr MPLUS . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 71
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 37

    (51) expr -> expr MMINUS . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 72
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 38

    (52) expr -> expr MMLTP . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 73
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 39

    (53) expr -> expr MDIV . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 74
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 40

    (54) expr -> expr EQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 75
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 41

    (55) expr -> expr NEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 76
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 42

    (56) expr -> expr GTEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 77
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 43

    (57) expr -> expr LTEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 78
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 44

    (58) expr -> expr > . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 79
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 45

    (59) expr -> expr < . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 80
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 46

    (6) struct -> instruction ; .

    INTNUM          reduce using rule 6 (struct -> instruction ; .)
    FLOATNUM        reduce using rule 6 (struct -> instruction ; .)
    STRING          reduce using rule 6 (struct -> instruction ; .)
    ZEROS           reduce using rule 6 (struct -> instruction ; .)
    ONES            reduce using rule 6 (struct -> instruction ; .)
    EYE             reduce using rule 6 (struct -> instruction ; .)
    (               reduce using rule 6 (struct -> instruction ; .)
    -               reduce using rule 6 (struct -> instruction ; .)
    [               reduce using rule 6 (struct -> instruction ; .)
    RETURN          reduce using rule 6 (struct -> instruction ; .)
    PRINT           reduce using rule 6 (struct -> instruction ; .)
    {               reduce using rule 6 (struct -> instruction ; .)
    ID              reduce using rule 6 (struct -> instruction ; .)
    IF              reduce using rule 6 (struct -> instruction ; .)
    WHILE           reduce using rule 6 (struct -> instruction ; .)
    FOR             reduce using rule 6 (struct -> instruction ; .)
    $end            reduce using rule 6 (struct -> instruction ; .)
    }               reduce using rule 6 (struct -> instruction ; .)
    ELSE            reduce using rule 6 (struct -> instruction ; .)


state 47

    (26) expr -> ZEROS ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 81
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 48

    (30) expr -> ( expr . )
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 82
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 49

    (27) expr -> ONES ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 83
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 50

    (28) expr -> EYE ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 84
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 51

    (40) assignment -> lvalue = . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    expr                           shift and go to state 85
    assignment                     shift and go to state 18

state 52

    (41) assignment -> lvalue PLUSASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    expr                           shift and go to state 86
    assignment                     shift and go to state 18

state 53

    (42) assignment -> lvalue MINASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    expr                           shift and go to state 87
    assignment                     shift and go to state 18

state 54

    (43) assignment -> lvalue MULTASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    expr                           shift and go to state 88
    assignment                     shift and go to state 18

state 55

    (44) assignment -> lvalue DIVASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    expr                           shift and go to state 89
    assignment                     shift and go to state 18

state 56

    (31) expr -> - expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 31 (expr -> - expr .)
    +               reduce using rule 31 (expr -> - expr .)
    -               reduce using rule 31 (expr -> - expr .)
    *               reduce using rule 31 (expr -> - expr .)
    /               reduce using rule 31 (expr -> - expr .)
    MPLUS           reduce using rule 31 (expr -> - expr .)
    MMINUS          reduce using rule 31 (expr -> - expr .)
    MMLTP           reduce using rule 31 (expr -> - expr .)
    MDIV            reduce using rule 31 (expr -> - expr .)
    EQ              reduce using rule 31 (expr -> - expr .)
    NEQ             reduce using rule 31 (expr -> - expr .)
    GTEQ            reduce using rule 31 (expr -> - expr .)
    LTEQ            reduce using rule 31 (expr -> - expr .)
    >               reduce using rule 31 (expr -> - expr .)
    <               reduce using rule 31 (expr -> - expr .)
    )               reduce using rule 31 (expr -> - expr .)
    ]               reduce using rule 31 (expr -> - expr .)
    ,               reduce using rule 31 (expr -> - expr .)
    :               reduce using rule 31 (expr -> - expr .)
    {               reduce using rule 31 (expr -> - expr .)
    BREAK           reduce using rule 31 (expr -> - expr .)
    CONTINUE        reduce using rule 31 (expr -> - expr .)
    IF              reduce using rule 31 (expr -> - expr .)
    WHILE           reduce using rule 31 (expr -> - expr .)
    FOR             reduce using rule 31 (expr -> - expr .)
    RETURN          reduce using rule 31 (expr -> - expr .)
    PRINT           reduce using rule 31 (expr -> - expr .)
    ID              reduce using rule 31 (expr -> - expr .)
    '               shift and go to state 31

  ! '               [ reduce using rule 31 (expr -> - expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! MMLTP           [ shift and go to state 38 ]
  ! MDIV            [ shift and go to state 39 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 57

    (36) expr -> [ array_interior . ]
    (33) array_interior -> array_interior . , expr

    ]               shift and go to state 90
    ,               shift and go to state 91


state 58

    (34) array_interior -> expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ]               reduce using rule 34 (array_interior -> expr .)
    ,               reduce using rule 34 (array_interior -> expr .)
    ;               reduce using rule 34 (array_interior -> expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 59

    (72) instruction -> RETURN expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 72 (instruction -> RETURN expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 60

    (73) instruction -> PRINT array_interior .
    (33) array_interior -> array_interior . , expr

    ;               reduce using rule 73 (instruction -> PRINT array_interior .)
    ,               shift and go to state 91


state 61

    (4) block -> { block_interior . }
    (10) block_interior -> block_interior . struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    }               shift and go to state 92
    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    struct                         shift and go to state 93
    expr                           shift and go to state 4
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 62

    (9) block_interior -> struct .

    }               reduce using rule 9 (block_interior -> struct .)
    INTNUM          reduce using rule 9 (block_interior -> struct .)
    FLOATNUM        reduce using rule 9 (block_interior -> struct .)
    STRING          reduce using rule 9 (block_interior -> struct .)
    ZEROS           reduce using rule 9 (block_interior -> struct .)
    ONES            reduce using rule 9 (block_interior -> struct .)
    EYE             reduce using rule 9 (block_interior -> struct .)
    (               reduce using rule 9 (block_interior -> struct .)
    -               reduce using rule 9 (block_interior -> struct .)
    [               reduce using rule 9 (block_interior -> struct .)
    RETURN          reduce using rule 9 (block_interior -> struct .)
    PRINT           reduce using rule 9 (block_interior -> struct .)
    {               reduce using rule 9 (block_interior -> struct .)
    ID              reduce using rule 9 (block_interior -> struct .)
    IF              reduce using rule 9 (block_interior -> struct .)
    WHILE           reduce using rule 9 (block_interior -> struct .)
    FOR             reduce using rule 9 (block_interior -> struct .)


state 63

    (38) lvalue -> ID [ . array_interior ]
    (39) lvalue -> ID [ . range ]
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (35) range -> . expr : expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    array_interior                 shift and go to state 94
    range                          shift and go to state 95
    expr                           shift and go to state 96
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 64

    (63) cond_if -> IF ( . expr ) struct
    (64) cond_if -> IF ( . expr ) struct ELSE struct
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 97
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 65

    (70) cond_while -> WHILE ( . expr ) loop_struct
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 98
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 66

    (71) cond_for -> FOR lvalue . = range loop_struct

    =               shift and go to state 99


state 67

    (46) expr -> expr + expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 46 (expr -> expr + expr .)
    +               reduce using rule 46 (expr -> expr + expr .)
    -               reduce using rule 46 (expr -> expr + expr .)
    MPLUS           reduce using rule 46 (expr -> expr + expr .)
    MMINUS          reduce using rule 46 (expr -> expr + expr .)
    EQ              reduce using rule 46 (expr -> expr + expr .)
    NEQ             reduce using rule 46 (expr -> expr + expr .)
    GTEQ            reduce using rule 46 (expr -> expr + expr .)
    LTEQ            reduce using rule 46 (expr -> expr + expr .)
    >               reduce using rule 46 (expr -> expr + expr .)
    <               reduce using rule 46 (expr -> expr + expr .)
    )               reduce using rule 46 (expr -> expr + expr .)
    ]               reduce using rule 46 (expr -> expr + expr .)
    ,               reduce using rule 46 (expr -> expr + expr .)
    :               reduce using rule 46 (expr -> expr + expr .)
    {               reduce using rule 46 (expr -> expr + expr .)
    BREAK           reduce using rule 46 (expr -> expr + expr .)
    CONTINUE        reduce using rule 46 (expr -> expr + expr .)
    IF              reduce using rule 46 (expr -> expr + expr .)
    WHILE           reduce using rule 46 (expr -> expr + expr .)
    FOR             reduce using rule 46 (expr -> expr + expr .)
    RETURN          reduce using rule 46 (expr -> expr + expr .)
    PRINT           reduce using rule 46 (expr -> expr + expr .)
    ID              reduce using rule 46 (expr -> expr + expr .)
    '               shift and go to state 31
    *               shift and go to state 34
    /               shift and go to state 35
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 46 (expr -> expr + expr .) ]
  ! *               [ reduce using rule 46 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr + expr .) ]
  ! MMLTP           [ reduce using rule 46 (expr -> expr + expr .) ]
  ! MDIV            [ reduce using rule 46 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 68

    (47) expr -> expr - expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 47 (expr -> expr - expr .)
    +               reduce using rule 47 (expr -> expr - expr .)
    -               reduce using rule 47 (expr -> expr - expr .)
    MPLUS           reduce using rule 47 (expr -> expr - expr .)
    MMINUS          reduce using rule 47 (expr -> expr - expr .)
    EQ              reduce using rule 47 (expr -> expr - expr .)
    NEQ             reduce using rule 47 (expr -> expr - expr .)
    GTEQ            reduce using rule 47 (expr -> expr - expr .)
    LTEQ            reduce using rule 47 (expr -> expr - expr .)
    >               reduce using rule 47 (expr -> expr - expr .)
    <               reduce using rule 47 (expr -> expr - expr .)
    )               reduce using rule 47 (expr -> expr - expr .)
    ]               reduce using rule 47 (expr -> expr - expr .)
    ,               reduce using rule 47 (expr -> expr - expr .)
    :               reduce using rule 47 (expr -> expr - expr .)
    {               reduce using rule 47 (expr -> expr - expr .)
    BREAK           reduce using rule 47 (expr -> expr - expr .)
    CONTINUE        reduce using rule 47 (expr -> expr - expr .)
    IF              reduce using rule 47 (expr -> expr - expr .)
    WHILE           reduce using rule 47 (expr -> expr - expr .)
    FOR             reduce using rule 47 (expr -> expr - expr .)
    RETURN          reduce using rule 47 (expr -> expr - expr .)
    PRINT           reduce using rule 47 (expr -> expr - expr .)
    ID              reduce using rule 47 (expr -> expr - expr .)
    '               shift and go to state 31
    *               shift and go to state 34
    /               shift and go to state 35
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 47 (expr -> expr - expr .) ]
  ! *               [ reduce using rule 47 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 47 (expr -> expr - expr .) ]
  ! MMLTP           [ reduce using rule 47 (expr -> expr - expr .) ]
  ! MDIV            [ reduce using rule 47 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 69

    (48) expr -> expr * expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 48 (expr -> expr * expr .)
    +               reduce using rule 48 (expr -> expr * expr .)
    -               reduce using rule 48 (expr -> expr * expr .)
    *               reduce using rule 48 (expr -> expr * expr .)
    /               reduce using rule 48 (expr -> expr * expr .)
    MPLUS           reduce using rule 48 (expr -> expr * expr .)
    MMINUS          reduce using rule 48 (expr -> expr * expr .)
    MMLTP           reduce using rule 48 (expr -> expr * expr .)
    MDIV            reduce using rule 48 (expr -> expr * expr .)
    EQ              reduce using rule 48 (expr -> expr * expr .)
    NEQ             reduce using rule 48 (expr -> expr * expr .)
    GTEQ            reduce using rule 48 (expr -> expr * expr .)
    LTEQ            reduce using rule 48 (expr -> expr * expr .)
    >               reduce using rule 48 (expr -> expr * expr .)
    <               reduce using rule 48 (expr -> expr * expr .)
    )               reduce using rule 48 (expr -> expr * expr .)
    ]               reduce using rule 48 (expr -> expr * expr .)
    ,               reduce using rule 48 (expr -> expr * expr .)
    :               reduce using rule 48 (expr -> expr * expr .)
    {               reduce using rule 48 (expr -> expr * expr .)
    BREAK           reduce using rule 48 (expr -> expr * expr .)
    CONTINUE        reduce using rule 48 (expr -> expr * expr .)
    IF              reduce using rule 48 (expr -> expr * expr .)
    WHILE           reduce using rule 48 (expr -> expr * expr .)
    FOR             reduce using rule 48 (expr -> expr * expr .)
    RETURN          reduce using rule 48 (expr -> expr * expr .)
    PRINT           reduce using rule 48 (expr -> expr * expr .)
    ID              reduce using rule 48 (expr -> expr * expr .)
    '               shift and go to state 31

  ! '               [ reduce using rule 48 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! MMLTP           [ shift and go to state 38 ]
  ! MDIV            [ shift and go to state 39 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 70

    (49) expr -> expr / expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 49 (expr -> expr / expr .)
    +               reduce using rule 49 (expr -> expr / expr .)
    -               reduce using rule 49 (expr -> expr / expr .)
    *               reduce using rule 49 (expr -> expr / expr .)
    /               reduce using rule 49 (expr -> expr / expr .)
    MPLUS           reduce using rule 49 (expr -> expr / expr .)
    MMINUS          reduce using rule 49 (expr -> expr / expr .)
    MMLTP           reduce using rule 49 (expr -> expr / expr .)
    MDIV            reduce using rule 49 (expr -> expr / expr .)
    EQ              reduce using rule 49 (expr -> expr / expr .)
    NEQ             reduce using rule 49 (expr -> expr / expr .)
    GTEQ            reduce using rule 49 (expr -> expr / expr .)
    LTEQ            reduce using rule 49 (expr -> expr / expr .)
    >               reduce using rule 49 (expr -> expr / expr .)
    <               reduce using rule 49 (expr -> expr / expr .)
    )               reduce using rule 49 (expr -> expr / expr .)
    ]               reduce using rule 49 (expr -> expr / expr .)
    ,               reduce using rule 49 (expr -> expr / expr .)
    :               reduce using rule 49 (expr -> expr / expr .)
    {               reduce using rule 49 (expr -> expr / expr .)
    BREAK           reduce using rule 49 (expr -> expr / expr .)
    CONTINUE        reduce using rule 49 (expr -> expr / expr .)
    IF              reduce using rule 49 (expr -> expr / expr .)
    WHILE           reduce using rule 49 (expr -> expr / expr .)
    FOR             reduce using rule 49 (expr -> expr / expr .)
    RETURN          reduce using rule 49 (expr -> expr / expr .)
    PRINT           reduce using rule 49 (expr -> expr / expr .)
    ID              reduce using rule 49 (expr -> expr / expr .)
    '               shift and go to state 31

  ! '               [ reduce using rule 49 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! MMLTP           [ shift and go to state 38 ]
  ! MDIV            [ shift and go to state 39 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 71

    (50) expr -> expr MPLUS expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 50 (expr -> expr MPLUS expr .)
    +               reduce using rule 50 (expr -> expr MPLUS expr .)
    -               reduce using rule 50 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 50 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 50 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 50 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 50 (expr -> expr MPLUS expr .)
    GTEQ            reduce using rule 50 (expr -> expr MPLUS expr .)
    LTEQ            reduce using rule 50 (expr -> expr MPLUS expr .)
    >               reduce using rule 50 (expr -> expr MPLUS expr .)
    <               reduce using rule 50 (expr -> expr MPLUS expr .)
    )               reduce using rule 50 (expr -> expr MPLUS expr .)
    ]               reduce using rule 50 (expr -> expr MPLUS expr .)
    ,               reduce using rule 50 (expr -> expr MPLUS expr .)
    :               reduce using rule 50 (expr -> expr MPLUS expr .)
    {               reduce using rule 50 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 50 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 50 (expr -> expr MPLUS expr .)
    IF              reduce using rule 50 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 50 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 50 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 50 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 50 (expr -> expr MPLUS expr .)
    ID              reduce using rule 50 (expr -> expr MPLUS expr .)
    '               shift and go to state 31
    *               shift and go to state 34
    /               shift and go to state 35
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 50 (expr -> expr MPLUS expr .) ]
  ! *               [ reduce using rule 50 (expr -> expr MPLUS expr .) ]
  ! /               [ reduce using rule 50 (expr -> expr MPLUS expr .) ]
  ! MMLTP           [ reduce using rule 50 (expr -> expr MPLUS expr .) ]
  ! MDIV            [ reduce using rule 50 (expr -> expr MPLUS expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 72

    (51) expr -> expr MMINUS expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 51 (expr -> expr MMINUS expr .)
    +               reduce using rule 51 (expr -> expr MMINUS expr .)
    -               reduce using rule 51 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 51 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 51 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 51 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 51 (expr -> expr MMINUS expr .)
    GTEQ            reduce using rule 51 (expr -> expr MMINUS expr .)
    LTEQ            reduce using rule 51 (expr -> expr MMINUS expr .)
    >               reduce using rule 51 (expr -> expr MMINUS expr .)
    <               reduce using rule 51 (expr -> expr MMINUS expr .)
    )               reduce using rule 51 (expr -> expr MMINUS expr .)
    ]               reduce using rule 51 (expr -> expr MMINUS expr .)
    ,               reduce using rule 51 (expr -> expr MMINUS expr .)
    :               reduce using rule 51 (expr -> expr MMINUS expr .)
    {               reduce using rule 51 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 51 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 51 (expr -> expr MMINUS expr .)
    IF              reduce using rule 51 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 51 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 51 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 51 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 51 (expr -> expr MMINUS expr .)
    ID              reduce using rule 51 (expr -> expr MMINUS expr .)
    '               shift and go to state 31
    *               shift and go to state 34
    /               shift and go to state 35
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 51 (expr -> expr MMINUS expr .) ]
  ! *               [ reduce using rule 51 (expr -> expr MMINUS expr .) ]
  ! /               [ reduce using rule 51 (expr -> expr MMINUS expr .) ]
  ! MMLTP           [ reduce using rule 51 (expr -> expr MMINUS expr .) ]
  ! MDIV            [ reduce using rule 51 (expr -> expr MMINUS expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 73

    (52) expr -> expr MMLTP expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 52 (expr -> expr MMLTP expr .)
    +               reduce using rule 52 (expr -> expr MMLTP expr .)
    -               reduce using rule 52 (expr -> expr MMLTP expr .)
    *               reduce using rule 52 (expr -> expr MMLTP expr .)
    /               reduce using rule 52 (expr -> expr MMLTP expr .)
    MPLUS           reduce using rule 52 (expr -> expr MMLTP expr .)
    MMINUS          reduce using rule 52 (expr -> expr MMLTP expr .)
    MMLTP           reduce using rule 52 (expr -> expr MMLTP expr .)
    MDIV            reduce using rule 52 (expr -> expr MMLTP expr .)
    EQ              reduce using rule 52 (expr -> expr MMLTP expr .)
    NEQ             reduce using rule 52 (expr -> expr MMLTP expr .)
    GTEQ            reduce using rule 52 (expr -> expr MMLTP expr .)
    LTEQ            reduce using rule 52 (expr -> expr MMLTP expr .)
    >               reduce using rule 52 (expr -> expr MMLTP expr .)
    <               reduce using rule 52 (expr -> expr MMLTP expr .)
    )               reduce using rule 52 (expr -> expr MMLTP expr .)
    ]               reduce using rule 52 (expr -> expr MMLTP expr .)
    ,               reduce using rule 52 (expr -> expr MMLTP expr .)
    :               reduce using rule 52 (expr -> expr MMLTP expr .)
    {               reduce using rule 52 (expr -> expr MMLTP expr .)
    BREAK           reduce using rule 52 (expr -> expr MMLTP expr .)
    CONTINUE        reduce using rule 52 (expr -> expr MMLTP expr .)
    IF              reduce using rule 52 (expr -> expr MMLTP expr .)
    WHILE           reduce using rule 52 (expr -> expr MMLTP expr .)
    FOR             reduce using rule 52 (expr -> expr MMLTP expr .)
    RETURN          reduce using rule 52 (expr -> expr MMLTP expr .)
    PRINT           reduce using rule 52 (expr -> expr MMLTP expr .)
    ID              reduce using rule 52 (expr -> expr MMLTP expr .)
    '               shift and go to state 31

  ! '               [ reduce using rule 52 (expr -> expr MMLTP expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! MMLTP           [ shift and go to state 38 ]
  ! MDIV            [ shift and go to state 39 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 74

    (53) expr -> expr MDIV expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 53 (expr -> expr MDIV expr .)
    +               reduce using rule 53 (expr -> expr MDIV expr .)
    -               reduce using rule 53 (expr -> expr MDIV expr .)
    *               reduce using rule 53 (expr -> expr MDIV expr .)
    /               reduce using rule 53 (expr -> expr MDIV expr .)
    MPLUS           reduce using rule 53 (expr -> expr MDIV expr .)
    MMINUS          reduce using rule 53 (expr -> expr MDIV expr .)
    MMLTP           reduce using rule 53 (expr -> expr MDIV expr .)
    MDIV            reduce using rule 53 (expr -> expr MDIV expr .)
    EQ              reduce using rule 53 (expr -> expr MDIV expr .)
    NEQ             reduce using rule 53 (expr -> expr MDIV expr .)
    GTEQ            reduce using rule 53 (expr -> expr MDIV expr .)
    LTEQ            reduce using rule 53 (expr -> expr MDIV expr .)
    >               reduce using rule 53 (expr -> expr MDIV expr .)
    <               reduce using rule 53 (expr -> expr MDIV expr .)
    )               reduce using rule 53 (expr -> expr MDIV expr .)
    ]               reduce using rule 53 (expr -> expr MDIV expr .)
    ,               reduce using rule 53 (expr -> expr MDIV expr .)
    :               reduce using rule 53 (expr -> expr MDIV expr .)
    {               reduce using rule 53 (expr -> expr MDIV expr .)
    BREAK           reduce using rule 53 (expr -> expr MDIV expr .)
    CONTINUE        reduce using rule 53 (expr -> expr MDIV expr .)
    IF              reduce using rule 53 (expr -> expr MDIV expr .)
    WHILE           reduce using rule 53 (expr -> expr MDIV expr .)
    FOR             reduce using rule 53 (expr -> expr MDIV expr .)
    RETURN          reduce using rule 53 (expr -> expr MDIV expr .)
    PRINT           reduce using rule 53 (expr -> expr MDIV expr .)
    ID              reduce using rule 53 (expr -> expr MDIV expr .)
    '               shift and go to state 31

  ! '               [ reduce using rule 53 (expr -> expr MDIV expr .) ]
  ! +               [ shift and go to state 32 ]
  ! -               [ shift and go to state 33 ]
  ! *               [ shift and go to state 34 ]
  ! /               [ shift and go to state 35 ]
  ! MPLUS           [ shift and go to state 36 ]
  ! MMINUS          [ shift and go to state 37 ]
  ! MMLTP           [ shift and go to state 38 ]
  ! MDIV            [ shift and go to state 39 ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 75

    (54) expr -> expr EQ expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 54 (expr -> expr EQ expr .)
    EQ              reduce using rule 54 (expr -> expr EQ expr .)
    NEQ             reduce using rule 54 (expr -> expr EQ expr .)
    GTEQ            reduce using rule 54 (expr -> expr EQ expr .)
    LTEQ            reduce using rule 54 (expr -> expr EQ expr .)
    >               reduce using rule 54 (expr -> expr EQ expr .)
    <               reduce using rule 54 (expr -> expr EQ expr .)
    )               reduce using rule 54 (expr -> expr EQ expr .)
    ]               reduce using rule 54 (expr -> expr EQ expr .)
    ,               reduce using rule 54 (expr -> expr EQ expr .)
    :               reduce using rule 54 (expr -> expr EQ expr .)
    {               reduce using rule 54 (expr -> expr EQ expr .)
    BREAK           reduce using rule 54 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 54 (expr -> expr EQ expr .)
    IF              reduce using rule 54 (expr -> expr EQ expr .)
    WHILE           reduce using rule 54 (expr -> expr EQ expr .)
    FOR             reduce using rule 54 (expr -> expr EQ expr .)
    RETURN          reduce using rule 54 (expr -> expr EQ expr .)
    PRINT           reduce using rule 54 (expr -> expr EQ expr .)
    ID              reduce using rule 54 (expr -> expr EQ expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! MPLUS           [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! MMINUS          [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! MMLTP           [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! MDIV            [ reduce using rule 54 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 76

    (55) expr -> expr NEQ expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 55 (expr -> expr NEQ expr .)
    EQ              reduce using rule 55 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 55 (expr -> expr NEQ expr .)
    GTEQ            reduce using rule 55 (expr -> expr NEQ expr .)
    LTEQ            reduce using rule 55 (expr -> expr NEQ expr .)
    >               reduce using rule 55 (expr -> expr NEQ expr .)
    <               reduce using rule 55 (expr -> expr NEQ expr .)
    )               reduce using rule 55 (expr -> expr NEQ expr .)
    ]               reduce using rule 55 (expr -> expr NEQ expr .)
    ,               reduce using rule 55 (expr -> expr NEQ expr .)
    :               reduce using rule 55 (expr -> expr NEQ expr .)
    {               reduce using rule 55 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 55 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 55 (expr -> expr NEQ expr .)
    IF              reduce using rule 55 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 55 (expr -> expr NEQ expr .)
    FOR             reduce using rule 55 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 55 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 55 (expr -> expr NEQ expr .)
    ID              reduce using rule 55 (expr -> expr NEQ expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! +               [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MPLUS           [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MMINUS          [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MMLTP           [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! MDIV            [ reduce using rule 55 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 77

    (56) expr -> expr GTEQ expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 56 (expr -> expr GTEQ expr .)
    EQ              reduce using rule 56 (expr -> expr GTEQ expr .)
    NEQ             reduce using rule 56 (expr -> expr GTEQ expr .)
    GTEQ            reduce using rule 56 (expr -> expr GTEQ expr .)
    LTEQ            reduce using rule 56 (expr -> expr GTEQ expr .)
    >               reduce using rule 56 (expr -> expr GTEQ expr .)
    <               reduce using rule 56 (expr -> expr GTEQ expr .)
    )               reduce using rule 56 (expr -> expr GTEQ expr .)
    ]               reduce using rule 56 (expr -> expr GTEQ expr .)
    ,               reduce using rule 56 (expr -> expr GTEQ expr .)
    :               reduce using rule 56 (expr -> expr GTEQ expr .)
    {               reduce using rule 56 (expr -> expr GTEQ expr .)
    BREAK           reduce using rule 56 (expr -> expr GTEQ expr .)
    CONTINUE        reduce using rule 56 (expr -> expr GTEQ expr .)
    IF              reduce using rule 56 (expr -> expr GTEQ expr .)
    WHILE           reduce using rule 56 (expr -> expr GTEQ expr .)
    FOR             reduce using rule 56 (expr -> expr GTEQ expr .)
    RETURN          reduce using rule 56 (expr -> expr GTEQ expr .)
    PRINT           reduce using rule 56 (expr -> expr GTEQ expr .)
    ID              reduce using rule 56 (expr -> expr GTEQ expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! +               [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! -               [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! *               [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! /               [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! MPLUS           [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! MMINUS          [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! MMLTP           [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! MDIV            [ reduce using rule 56 (expr -> expr GTEQ expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 78

    (57) expr -> expr LTEQ expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 57 (expr -> expr LTEQ expr .)
    EQ              reduce using rule 57 (expr -> expr LTEQ expr .)
    NEQ             reduce using rule 57 (expr -> expr LTEQ expr .)
    GTEQ            reduce using rule 57 (expr -> expr LTEQ expr .)
    LTEQ            reduce using rule 57 (expr -> expr LTEQ expr .)
    >               reduce using rule 57 (expr -> expr LTEQ expr .)
    <               reduce using rule 57 (expr -> expr LTEQ expr .)
    )               reduce using rule 57 (expr -> expr LTEQ expr .)
    ]               reduce using rule 57 (expr -> expr LTEQ expr .)
    ,               reduce using rule 57 (expr -> expr LTEQ expr .)
    :               reduce using rule 57 (expr -> expr LTEQ expr .)
    {               reduce using rule 57 (expr -> expr LTEQ expr .)
    BREAK           reduce using rule 57 (expr -> expr LTEQ expr .)
    CONTINUE        reduce using rule 57 (expr -> expr LTEQ expr .)
    IF              reduce using rule 57 (expr -> expr LTEQ expr .)
    WHILE           reduce using rule 57 (expr -> expr LTEQ expr .)
    FOR             reduce using rule 57 (expr -> expr LTEQ expr .)
    RETURN          reduce using rule 57 (expr -> expr LTEQ expr .)
    PRINT           reduce using rule 57 (expr -> expr LTEQ expr .)
    ID              reduce using rule 57 (expr -> expr LTEQ expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! +               [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! -               [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! *               [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! /               [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! MPLUS           [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! MMINUS          [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! MMLTP           [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! MDIV            [ reduce using rule 57 (expr -> expr LTEQ expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 79

    (58) expr -> expr > expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 58 (expr -> expr > expr .)
    EQ              reduce using rule 58 (expr -> expr > expr .)
    NEQ             reduce using rule 58 (expr -> expr > expr .)
    GTEQ            reduce using rule 58 (expr -> expr > expr .)
    LTEQ            reduce using rule 58 (expr -> expr > expr .)
    >               reduce using rule 58 (expr -> expr > expr .)
    <               reduce using rule 58 (expr -> expr > expr .)
    )               reduce using rule 58 (expr -> expr > expr .)
    ]               reduce using rule 58 (expr -> expr > expr .)
    ,               reduce using rule 58 (expr -> expr > expr .)
    :               reduce using rule 58 (expr -> expr > expr .)
    {               reduce using rule 58 (expr -> expr > expr .)
    BREAK           reduce using rule 58 (expr -> expr > expr .)
    CONTINUE        reduce using rule 58 (expr -> expr > expr .)
    IF              reduce using rule 58 (expr -> expr > expr .)
    WHILE           reduce using rule 58 (expr -> expr > expr .)
    FOR             reduce using rule 58 (expr -> expr > expr .)
    RETURN          reduce using rule 58 (expr -> expr > expr .)
    PRINT           reduce using rule 58 (expr -> expr > expr .)
    ID              reduce using rule 58 (expr -> expr > expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 58 (expr -> expr > expr .) ]
  ! +               [ reduce using rule 58 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 58 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 58 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 58 (expr -> expr > expr .) ]
  ! MPLUS           [ reduce using rule 58 (expr -> expr > expr .) ]
  ! MMINUS          [ reduce using rule 58 (expr -> expr > expr .) ]
  ! MMLTP           [ reduce using rule 58 (expr -> expr > expr .) ]
  ! MDIV            [ reduce using rule 58 (expr -> expr > expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 80

    (59) expr -> expr < expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 59 (expr -> expr < expr .)
    EQ              reduce using rule 59 (expr -> expr < expr .)
    NEQ             reduce using rule 59 (expr -> expr < expr .)
    GTEQ            reduce using rule 59 (expr -> expr < expr .)
    LTEQ            reduce using rule 59 (expr -> expr < expr .)
    >               reduce using rule 59 (expr -> expr < expr .)
    <               reduce using rule 59 (expr -> expr < expr .)
    )               reduce using rule 59 (expr -> expr < expr .)
    ]               reduce using rule 59 (expr -> expr < expr .)
    ,               reduce using rule 59 (expr -> expr < expr .)
    :               reduce using rule 59 (expr -> expr < expr .)
    {               reduce using rule 59 (expr -> expr < expr .)
    BREAK           reduce using rule 59 (expr -> expr < expr .)
    CONTINUE        reduce using rule 59 (expr -> expr < expr .)
    IF              reduce using rule 59 (expr -> expr < expr .)
    WHILE           reduce using rule 59 (expr -> expr < expr .)
    FOR             reduce using rule 59 (expr -> expr < expr .)
    RETURN          reduce using rule 59 (expr -> expr < expr .)
    PRINT           reduce using rule 59 (expr -> expr < expr .)
    ID              reduce using rule 59 (expr -> expr < expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39

  ! '               [ reduce using rule 59 (expr -> expr < expr .) ]
  ! +               [ reduce using rule 59 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 59 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 59 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 59 (expr -> expr < expr .) ]
  ! MPLUS           [ reduce using rule 59 (expr -> expr < expr .) ]
  ! MMINUS          [ reduce using rule 59 (expr -> expr < expr .) ]
  ! MMLTP           [ reduce using rule 59 (expr -> expr < expr .) ]
  ! MDIV            [ reduce using rule 59 (expr -> expr < expr .) ]
  ! EQ              [ shift and go to state 40 ]
  ! NEQ             [ shift and go to state 41 ]
  ! GTEQ            [ shift and go to state 42 ]
  ! LTEQ            [ shift and go to state 43 ]
  ! >               [ shift and go to state 44 ]
  ! <               [ shift and go to state 45 ]


state 81

    (26) expr -> ZEROS ( expr . )
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 100
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 82

    (30) expr -> ( expr ) .

    ;               reduce using rule 30 (expr -> ( expr ) .)
    '               reduce using rule 30 (expr -> ( expr ) .)
    +               reduce using rule 30 (expr -> ( expr ) .)
    -               reduce using rule 30 (expr -> ( expr ) .)
    *               reduce using rule 30 (expr -> ( expr ) .)
    /               reduce using rule 30 (expr -> ( expr ) .)
    MPLUS           reduce using rule 30 (expr -> ( expr ) .)
    MMINUS          reduce using rule 30 (expr -> ( expr ) .)
    MMLTP           reduce using rule 30 (expr -> ( expr ) .)
    MDIV            reduce using rule 30 (expr -> ( expr ) .)
    EQ              reduce using rule 30 (expr -> ( expr ) .)
    NEQ             reduce using rule 30 (expr -> ( expr ) .)
    GTEQ            reduce using rule 30 (expr -> ( expr ) .)
    LTEQ            reduce using rule 30 (expr -> ( expr ) .)
    >               reduce using rule 30 (expr -> ( expr ) .)
    <               reduce using rule 30 (expr -> ( expr ) .)
    )               reduce using rule 30 (expr -> ( expr ) .)
    ]               reduce using rule 30 (expr -> ( expr ) .)
    ,               reduce using rule 30 (expr -> ( expr ) .)
    :               reduce using rule 30 (expr -> ( expr ) .)
    {               reduce using rule 30 (expr -> ( expr ) .)
    BREAK           reduce using rule 30 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 30 (expr -> ( expr ) .)
    IF              reduce using rule 30 (expr -> ( expr ) .)
    WHILE           reduce using rule 30 (expr -> ( expr ) .)
    FOR             reduce using rule 30 (expr -> ( expr ) .)
    RETURN          reduce using rule 30 (expr -> ( expr ) .)
    PRINT           reduce using rule 30 (expr -> ( expr ) .)
    ID              reduce using rule 30 (expr -> ( expr ) .)


state 83

    (27) expr -> ONES ( expr . )
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 101
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 84

    (28) expr -> EYE ( expr . )
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 102
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 85

    (40) assignment -> lvalue = expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 40 (assignment -> lvalue = expr .)
    )               reduce using rule 40 (assignment -> lvalue = expr .)
    ]               reduce using rule 40 (assignment -> lvalue = expr .)
    ,               reduce using rule 40 (assignment -> lvalue = expr .)
    :               reduce using rule 40 (assignment -> lvalue = expr .)
    {               reduce using rule 40 (assignment -> lvalue = expr .)
    BREAK           reduce using rule 40 (assignment -> lvalue = expr .)
    CONTINUE        reduce using rule 40 (assignment -> lvalue = expr .)
    IF              reduce using rule 40 (assignment -> lvalue = expr .)
    WHILE           reduce using rule 40 (assignment -> lvalue = expr .)
    FOR             reduce using rule 40 (assignment -> lvalue = expr .)
    RETURN          reduce using rule 40 (assignment -> lvalue = expr .)
    PRINT           reduce using rule 40 (assignment -> lvalue = expr .)
    ID              reduce using rule 40 (assignment -> lvalue = expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45

  ! '               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! +               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! -               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! *               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! /               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! MPLUS           [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! MMINUS          [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! MMLTP           [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! MDIV            [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! EQ              [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! NEQ             [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! GTEQ            [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! LTEQ            [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! >               [ reduce using rule 40 (assignment -> lvalue = expr .) ]
  ! <               [ reduce using rule 40 (assignment -> lvalue = expr .) ]


state 86

    (41) assignment -> lvalue PLUSASSIGN expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    )               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    ]               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    ,               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    :               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    {               reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    BREAK           reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    CONTINUE        reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    IF              reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    WHILE           reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    FOR             reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    RETURN          reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    PRINT           reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    ID              reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45

  ! '               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! +               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! -               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! *               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! /               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MDIV            [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! EQ              [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! NEQ             [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! >               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! <               [ reduce using rule 41 (assignment -> lvalue PLUSASSIGN expr .) ]


state 87

    (42) assignment -> lvalue MINASSIGN expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    )               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    ]               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    ,               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    :               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    {               reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    BREAK           reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    CONTINUE        reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    IF              reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    WHILE           reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    FOR             reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    RETURN          reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    PRINT           reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    ID              reduce using rule 42 (assignment -> lvalue MINASSIGN expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45

  ! '               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! +               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! -               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! *               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! /               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! MDIV            [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! EQ              [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! NEQ             [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! >               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]
  ! <               [ reduce using rule 42 (assignment -> lvalue MINASSIGN expr .) ]


state 88

    (43) assignment -> lvalue MULTASSIGN expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    )               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    ]               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    ,               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    :               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    {               reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    BREAK           reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    CONTINUE        reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    IF              reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    WHILE           reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    FOR             reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    RETURN          reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    PRINT           reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    ID              reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45

  ! '               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! +               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! -               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! *               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! /               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MDIV            [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! EQ              [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! NEQ             [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! >               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]
  ! <               [ reduce using rule 43 (assignment -> lvalue MULTASSIGN expr .) ]


state 89

    (44) assignment -> lvalue DIVASSIGN expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    )               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    ]               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    ,               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    :               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    {               reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    BREAK           reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    CONTINUE        reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    IF              reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    WHILE           reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    FOR             reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    RETURN          reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    PRINT           reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    ID              reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45

  ! '               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! +               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! -               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! *               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! /               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MDIV            [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! EQ              [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! NEQ             [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! >               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]
  ! <               [ reduce using rule 44 (assignment -> lvalue DIVASSIGN expr .) ]


state 90

    (36) expr -> [ array_interior ] .

    ;               reduce using rule 36 (expr -> [ array_interior ] .)
    '               reduce using rule 36 (expr -> [ array_interior ] .)
    +               reduce using rule 36 (expr -> [ array_interior ] .)
    -               reduce using rule 36 (expr -> [ array_interior ] .)
    *               reduce using rule 36 (expr -> [ array_interior ] .)
    /               reduce using rule 36 (expr -> [ array_interior ] .)
    MPLUS           reduce using rule 36 (expr -> [ array_interior ] .)
    MMINUS          reduce using rule 36 (expr -> [ array_interior ] .)
    MMLTP           reduce using rule 36 (expr -> [ array_interior ] .)
    MDIV            reduce using rule 36 (expr -> [ array_interior ] .)
    EQ              reduce using rule 36 (expr -> [ array_interior ] .)
    NEQ             reduce using rule 36 (expr -> [ array_interior ] .)
    GTEQ            reduce using rule 36 (expr -> [ array_interior ] .)
    LTEQ            reduce using rule 36 (expr -> [ array_interior ] .)
    >               reduce using rule 36 (expr -> [ array_interior ] .)
    <               reduce using rule 36 (expr -> [ array_interior ] .)
    )               reduce using rule 36 (expr -> [ array_interior ] .)
    ]               reduce using rule 36 (expr -> [ array_interior ] .)
    ,               reduce using rule 36 (expr -> [ array_interior ] .)
    :               reduce using rule 36 (expr -> [ array_interior ] .)
    {               reduce using rule 36 (expr -> [ array_interior ] .)
    BREAK           reduce using rule 36 (expr -> [ array_interior ] .)
    CONTINUE        reduce using rule 36 (expr -> [ array_interior ] .)
    IF              reduce using rule 36 (expr -> [ array_interior ] .)
    WHILE           reduce using rule 36 (expr -> [ array_interior ] .)
    FOR             reduce using rule 36 (expr -> [ array_interior ] .)
    RETURN          reduce using rule 36 (expr -> [ array_interior ] .)
    PRINT           reduce using rule 36 (expr -> [ array_interior ] .)
    ID              reduce using rule 36 (expr -> [ array_interior ] .)


state 91

    (33) array_interior -> array_interior , . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 103
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 92

    (4) block -> { block_interior } .

    INTNUM          reduce using rule 4 (block -> { block_interior } .)
    FLOATNUM        reduce using rule 4 (block -> { block_interior } .)
    STRING          reduce using rule 4 (block -> { block_interior } .)
    ZEROS           reduce using rule 4 (block -> { block_interior } .)
    ONES            reduce using rule 4 (block -> { block_interior } .)
    EYE             reduce using rule 4 (block -> { block_interior } .)
    (               reduce using rule 4 (block -> { block_interior } .)
    -               reduce using rule 4 (block -> { block_interior } .)
    [               reduce using rule 4 (block -> { block_interior } .)
    RETURN          reduce using rule 4 (block -> { block_interior } .)
    PRINT           reduce using rule 4 (block -> { block_interior } .)
    {               reduce using rule 4 (block -> { block_interior } .)
    ID              reduce using rule 4 (block -> { block_interior } .)
    IF              reduce using rule 4 (block -> { block_interior } .)
    WHILE           reduce using rule 4 (block -> { block_interior } .)
    FOR             reduce using rule 4 (block -> { block_interior } .)
    $end            reduce using rule 4 (block -> { block_interior } .)
    }               reduce using rule 4 (block -> { block_interior } .)
    ELSE            reduce using rule 4 (block -> { block_interior } .)


state 93

    (10) block_interior -> block_interior struct .

    }               reduce using rule 10 (block_interior -> block_interior struct .)
    INTNUM          reduce using rule 10 (block_interior -> block_interior struct .)
    FLOATNUM        reduce using rule 10 (block_interior -> block_interior struct .)
    STRING          reduce using rule 10 (block_interior -> block_interior struct .)
    ZEROS           reduce using rule 10 (block_interior -> block_interior struct .)
    ONES            reduce using rule 10 (block_interior -> block_interior struct .)
    EYE             reduce using rule 10 (block_interior -> block_interior struct .)
    (               reduce using rule 10 (block_interior -> block_interior struct .)
    -               reduce using rule 10 (block_interior -> block_interior struct .)
    [               reduce using rule 10 (block_interior -> block_interior struct .)
    RETURN          reduce using rule 10 (block_interior -> block_interior struct .)
    PRINT           reduce using rule 10 (block_interior -> block_interior struct .)
    {               reduce using rule 10 (block_interior -> block_interior struct .)
    ID              reduce using rule 10 (block_interior -> block_interior struct .)
    IF              reduce using rule 10 (block_interior -> block_interior struct .)
    WHILE           reduce using rule 10 (block_interior -> block_interior struct .)
    FOR             reduce using rule 10 (block_interior -> block_interior struct .)


state 94

    (38) lvalue -> ID [ array_interior . ]
    (33) array_interior -> array_interior . , expr

    ]               shift and go to state 104
    ,               shift and go to state 91


state 95

    (39) lvalue -> ID [ range . ]

    ]               shift and go to state 105


state 96

    (34) array_interior -> expr .
    (35) range -> expr . : expr
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ]               reduce using rule 34 (array_interior -> expr .)
    ,               reduce using rule 34 (array_interior -> expr .)
    :               shift and go to state 106
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 97

    (63) cond_if -> IF ( expr . ) struct
    (64) cond_if -> IF ( expr . ) struct ELSE struct
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 107
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 98

    (70) cond_while -> WHILE ( expr . ) loop_struct
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 108
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 99

    (71) cond_for -> FOR lvalue = . range loop_struct
    (35) range -> . expr : expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    lvalue                         shift and go to state 15
    range                          shift and go to state 109
    expr                           shift and go to state 110
    assignment                     shift and go to state 18

state 100

    (26) expr -> ZEROS ( expr ) .

    ;               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MMLTP           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MDIV            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    NEQ             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    GTEQ            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    LTEQ            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ]               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    :               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 26 (expr -> ZEROS ( expr ) .)


state 101

    (27) expr -> ONES ( expr ) .

    ;               reduce using rule 27 (expr -> ONES ( expr ) .)
    '               reduce using rule 27 (expr -> ONES ( expr ) .)
    +               reduce using rule 27 (expr -> ONES ( expr ) .)
    -               reduce using rule 27 (expr -> ONES ( expr ) .)
    *               reduce using rule 27 (expr -> ONES ( expr ) .)
    /               reduce using rule 27 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 27 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 27 (expr -> ONES ( expr ) .)
    MMLTP           reduce using rule 27 (expr -> ONES ( expr ) .)
    MDIV            reduce using rule 27 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 27 (expr -> ONES ( expr ) .)
    NEQ             reduce using rule 27 (expr -> ONES ( expr ) .)
    GTEQ            reduce using rule 27 (expr -> ONES ( expr ) .)
    LTEQ            reduce using rule 27 (expr -> ONES ( expr ) .)
    >               reduce using rule 27 (expr -> ONES ( expr ) .)
    <               reduce using rule 27 (expr -> ONES ( expr ) .)
    )               reduce using rule 27 (expr -> ONES ( expr ) .)
    ]               reduce using rule 27 (expr -> ONES ( expr ) .)
    ,               reduce using rule 27 (expr -> ONES ( expr ) .)
    :               reduce using rule 27 (expr -> ONES ( expr ) .)
    {               reduce using rule 27 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 27 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 27 (expr -> ONES ( expr ) .)
    IF              reduce using rule 27 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 27 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 27 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 27 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 27 (expr -> ONES ( expr ) .)
    ID              reduce using rule 27 (expr -> ONES ( expr ) .)


state 102

    (28) expr -> EYE ( expr ) .

    ;               reduce using rule 28 (expr -> EYE ( expr ) .)
    '               reduce using rule 28 (expr -> EYE ( expr ) .)
    +               reduce using rule 28 (expr -> EYE ( expr ) .)
    -               reduce using rule 28 (expr -> EYE ( expr ) .)
    *               reduce using rule 28 (expr -> EYE ( expr ) .)
    /               reduce using rule 28 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 28 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 28 (expr -> EYE ( expr ) .)
    MMLTP           reduce using rule 28 (expr -> EYE ( expr ) .)
    MDIV            reduce using rule 28 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 28 (expr -> EYE ( expr ) .)
    NEQ             reduce using rule 28 (expr -> EYE ( expr ) .)
    GTEQ            reduce using rule 28 (expr -> EYE ( expr ) .)
    LTEQ            reduce using rule 28 (expr -> EYE ( expr ) .)
    >               reduce using rule 28 (expr -> EYE ( expr ) .)
    <               reduce using rule 28 (expr -> EYE ( expr ) .)
    )               reduce using rule 28 (expr -> EYE ( expr ) .)
    ]               reduce using rule 28 (expr -> EYE ( expr ) .)
    ,               reduce using rule 28 (expr -> EYE ( expr ) .)
    :               reduce using rule 28 (expr -> EYE ( expr ) .)
    {               reduce using rule 28 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 28 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 28 (expr -> EYE ( expr ) .)
    IF              reduce using rule 28 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 28 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 28 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 28 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 28 (expr -> EYE ( expr ) .)
    ID              reduce using rule 28 (expr -> EYE ( expr ) .)


state 103

    (33) array_interior -> array_interior , expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ]               reduce using rule 33 (array_interior -> array_interior , expr .)
    ,               reduce using rule 33 (array_interior -> array_interior , expr .)
    ;               reduce using rule 33 (array_interior -> array_interior , expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 104

    (38) lvalue -> ID [ array_interior ] .

    =               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    PLUSASSIGN      reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MINASSIGN       reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MULTASSIGN      reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    DIVASSIGN       reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    ;               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    '               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    +               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    -               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    *               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    /               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MPLUS           reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MMINUS          reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MMLTP           reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    MDIV            reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    EQ              reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    NEQ             reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    GTEQ            reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    LTEQ            reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    >               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    <               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    )               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    ]               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    ,               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    :               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    {               reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    BREAK           reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    CONTINUE        reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    IF              reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    WHILE           reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    FOR             reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    RETURN          reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    PRINT           reduce using rule 38 (lvalue -> ID [ array_interior ] .)
    ID              reduce using rule 38 (lvalue -> ID [ array_interior ] .)


state 105

    (39) lvalue -> ID [ range ] .

    =               reduce using rule 39 (lvalue -> ID [ range ] .)
    PLUSASSIGN      reduce using rule 39 (lvalue -> ID [ range ] .)
    MINASSIGN       reduce using rule 39 (lvalue -> ID [ range ] .)
    MULTASSIGN      reduce using rule 39 (lvalue -> ID [ range ] .)
    DIVASSIGN       reduce using rule 39 (lvalue -> ID [ range ] .)
    ;               reduce using rule 39 (lvalue -> ID [ range ] .)
    '               reduce using rule 39 (lvalue -> ID [ range ] .)
    +               reduce using rule 39 (lvalue -> ID [ range ] .)
    -               reduce using rule 39 (lvalue -> ID [ range ] .)
    *               reduce using rule 39 (lvalue -> ID [ range ] .)
    /               reduce using rule 39 (lvalue -> ID [ range ] .)
    MPLUS           reduce using rule 39 (lvalue -> ID [ range ] .)
    MMINUS          reduce using rule 39 (lvalue -> ID [ range ] .)
    MMLTP           reduce using rule 39 (lvalue -> ID [ range ] .)
    MDIV            reduce using rule 39 (lvalue -> ID [ range ] .)
    EQ              reduce using rule 39 (lvalue -> ID [ range ] .)
    NEQ             reduce using rule 39 (lvalue -> ID [ range ] .)
    GTEQ            reduce using rule 39 (lvalue -> ID [ range ] .)
    LTEQ            reduce using rule 39 (lvalue -> ID [ range ] .)
    >               reduce using rule 39 (lvalue -> ID [ range ] .)
    <               reduce using rule 39 (lvalue -> ID [ range ] .)
    )               reduce using rule 39 (lvalue -> ID [ range ] .)
    ]               reduce using rule 39 (lvalue -> ID [ range ] .)
    ,               reduce using rule 39 (lvalue -> ID [ range ] .)
    :               reduce using rule 39 (lvalue -> ID [ range ] .)
    {               reduce using rule 39 (lvalue -> ID [ range ] .)
    BREAK           reduce using rule 39 (lvalue -> ID [ range ] .)
    CONTINUE        reduce using rule 39 (lvalue -> ID [ range ] .)
    IF              reduce using rule 39 (lvalue -> ID [ range ] .)
    WHILE           reduce using rule 39 (lvalue -> ID [ range ] .)
    FOR             reduce using rule 39 (lvalue -> ID [ range ] .)
    RETURN          reduce using rule 39 (lvalue -> ID [ range ] .)
    PRINT           reduce using rule 39 (lvalue -> ID [ range ] .)
    ID              reduce using rule 39 (lvalue -> ID [ range ] .)


state 106

    (35) range -> expr : . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 111
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 107

    (63) cond_if -> IF ( expr ) . struct
    (64) cond_if -> IF ( expr ) . struct ELSE struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    expr                           shift and go to state 4
    struct                         shift and go to state 112
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 108

    (70) cond_while -> WHILE ( expr ) . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . loop_block
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (11) loop_block -> . { loop_block_interior }
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]

    {               shift and go to state 122
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    ID              shift and go to state 25

    loop_struct                    shift and go to state 113
    loop_single_stmt               shift and go to state 114
    loop_cond_expr                 shift and go to state 115
    loop_block                     shift and go to state 116
    loop_instruction               shift and go to state 117
    assignment                     shift and go to state 118
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121
    instruction                    shift and go to state 125
    lvalue                         shift and go to state 126

state 109

    (71) cond_for -> FOR lvalue = range . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . loop_block
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (11) loop_block -> . { loop_block_interior }
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]

    {               shift and go to state 122
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    ID              shift and go to state 25

    lvalue                         shift and go to state 126
    loop_struct                    shift and go to state 128
    loop_single_stmt               shift and go to state 114
    loop_cond_expr                 shift and go to state 115
    loop_block                     shift and go to state 116
    loop_instruction               shift and go to state 117
    assignment                     shift and go to state 118
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121
    instruction                    shift and go to state 125

state 110

    (35) range -> expr . : expr
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    :               shift and go to state 106
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 111

    (35) range -> expr : expr .
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ]               reduce using rule 35 (range -> expr : expr .)
    {               reduce using rule 35 (range -> expr : expr .)
    BREAK           reduce using rule 35 (range -> expr : expr .)
    CONTINUE        reduce using rule 35 (range -> expr : expr .)
    IF              reduce using rule 35 (range -> expr : expr .)
    WHILE           reduce using rule 35 (range -> expr : expr .)
    FOR             reduce using rule 35 (range -> expr : expr .)
    RETURN          reduce using rule 35 (range -> expr : expr .)
    PRINT           reduce using rule 35 (range -> expr : expr .)
    ID              reduce using rule 35 (range -> expr : expr .)
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 112

    (63) cond_if -> IF ( expr ) struct .
    (64) cond_if -> IF ( expr ) struct . ELSE struct

    INTNUM          reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    FLOATNUM        reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    STRING          reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    ZEROS           reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    ONES            reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    EYE             reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    (               reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    -               reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    [               reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    RETURN          reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    PRINT           reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    {               reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    ID              reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    IF              reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    WHILE           reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    FOR             reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    $end            reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    }               reduce using rule 63 (cond_if -> IF ( expr ) struct .)
    ELSE            shift and go to state 129

  ! ELSE            [ reduce using rule 63 (cond_if -> IF ( expr ) struct .) ]


state 113

    (70) cond_while -> WHILE ( expr ) loop_struct .

    INTNUM          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    FLOATNUM        reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    STRING          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    ZEROS           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    ONES            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    EYE             reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    (               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    -               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    [               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    RETURN          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    PRINT           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    {               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    ID              reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    IF              reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    WHILE           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    FOR             reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    $end            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    }               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    ELSE            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    BREAK           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)
    CONTINUE        reduce using rule 70 (cond_while -> WHILE ( expr ) loop_struct .)


state 114

    (12) loop_struct -> loop_single_stmt . ;

    ;               shift and go to state 130


state 115

    (13) loop_struct -> loop_cond_expr .

    INTNUM          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    FLOATNUM        reduce using rule 13 (loop_struct -> loop_cond_expr .)
    STRING          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ZEROS           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ONES            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    EYE             reduce using rule 13 (loop_struct -> loop_cond_expr .)
    (               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    -               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    [               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    RETURN          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    PRINT           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    {               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ID              reduce using rule 13 (loop_struct -> loop_cond_expr .)
    IF              reduce using rule 13 (loop_struct -> loop_cond_expr .)
    WHILE           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    FOR             reduce using rule 13 (loop_struct -> loop_cond_expr .)
    $end            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    }               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ELSE            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    BREAK           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    CONTINUE        reduce using rule 13 (loop_struct -> loop_cond_expr .)


state 116

    (14) loop_struct -> loop_block .

    INTNUM          reduce using rule 14 (loop_struct -> loop_block .)
    FLOATNUM        reduce using rule 14 (loop_struct -> loop_block .)
    STRING          reduce using rule 14 (loop_struct -> loop_block .)
    ZEROS           reduce using rule 14 (loop_struct -> loop_block .)
    ONES            reduce using rule 14 (loop_struct -> loop_block .)
    EYE             reduce using rule 14 (loop_struct -> loop_block .)
    (               reduce using rule 14 (loop_struct -> loop_block .)
    -               reduce using rule 14 (loop_struct -> loop_block .)
    [               reduce using rule 14 (loop_struct -> loop_block .)
    RETURN          reduce using rule 14 (loop_struct -> loop_block .)
    PRINT           reduce using rule 14 (loop_struct -> loop_block .)
    {               reduce using rule 14 (loop_struct -> loop_block .)
    ID              reduce using rule 14 (loop_struct -> loop_block .)
    IF              reduce using rule 14 (loop_struct -> loop_block .)
    WHILE           reduce using rule 14 (loop_struct -> loop_block .)
    FOR             reduce using rule 14 (loop_struct -> loop_block .)
    $end            reduce using rule 14 (loop_struct -> loop_block .)
    }               reduce using rule 14 (loop_struct -> loop_block .)
    ELSE            reduce using rule 14 (loop_struct -> loop_block .)
    BREAK           reduce using rule 14 (loop_struct -> loop_block .)
    CONTINUE        reduce using rule 14 (loop_struct -> loop_block .)


state 117

    (21) loop_single_stmt -> loop_instruction .

    ;               reduce using rule 21 (loop_single_stmt -> loop_instruction .)


state 118

    (22) loop_single_stmt -> assignment .

    ;               reduce using rule 22 (loop_single_stmt -> assignment .)


state 119

    (65) loop_cond_expr -> loop_cond_if .

    INTNUM          reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    FLOATNUM        reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    STRING          reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    ZEROS           reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    ONES            reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    EYE             reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    (               reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    -               reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    [               reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    RETURN          reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    PRINT           reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    {               reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    ID              reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    IF              reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    WHILE           reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    FOR             reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    $end            reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    }               reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    ELSE            reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    BREAK           reduce using rule 65 (loop_cond_expr -> loop_cond_if .)
    CONTINUE        reduce using rule 65 (loop_cond_expr -> loop_cond_if .)


state 120

    (66) loop_cond_expr -> cond_while .

    INTNUM          reduce using rule 66 (loop_cond_expr -> cond_while .)
    FLOATNUM        reduce using rule 66 (loop_cond_expr -> cond_while .)
    STRING          reduce using rule 66 (loop_cond_expr -> cond_while .)
    ZEROS           reduce using rule 66 (loop_cond_expr -> cond_while .)
    ONES            reduce using rule 66 (loop_cond_expr -> cond_while .)
    EYE             reduce using rule 66 (loop_cond_expr -> cond_while .)
    (               reduce using rule 66 (loop_cond_expr -> cond_while .)
    -               reduce using rule 66 (loop_cond_expr -> cond_while .)
    [               reduce using rule 66 (loop_cond_expr -> cond_while .)
    RETURN          reduce using rule 66 (loop_cond_expr -> cond_while .)
    PRINT           reduce using rule 66 (loop_cond_expr -> cond_while .)
    {               reduce using rule 66 (loop_cond_expr -> cond_while .)
    ID              reduce using rule 66 (loop_cond_expr -> cond_while .)
    IF              reduce using rule 66 (loop_cond_expr -> cond_while .)
    WHILE           reduce using rule 66 (loop_cond_expr -> cond_while .)
    FOR             reduce using rule 66 (loop_cond_expr -> cond_while .)
    $end            reduce using rule 66 (loop_cond_expr -> cond_while .)
    }               reduce using rule 66 (loop_cond_expr -> cond_while .)
    ELSE            reduce using rule 66 (loop_cond_expr -> cond_while .)
    BREAK           reduce using rule 66 (loop_cond_expr -> cond_while .)
    CONTINUE        reduce using rule 66 (loop_cond_expr -> cond_while .)


state 121

    (67) loop_cond_expr -> cond_for .

    INTNUM          reduce using rule 67 (loop_cond_expr -> cond_for .)
    FLOATNUM        reduce using rule 67 (loop_cond_expr -> cond_for .)
    STRING          reduce using rule 67 (loop_cond_expr -> cond_for .)
    ZEROS           reduce using rule 67 (loop_cond_expr -> cond_for .)
    ONES            reduce using rule 67 (loop_cond_expr -> cond_for .)
    EYE             reduce using rule 67 (loop_cond_expr -> cond_for .)
    (               reduce using rule 67 (loop_cond_expr -> cond_for .)
    -               reduce using rule 67 (loop_cond_expr -> cond_for .)
    [               reduce using rule 67 (loop_cond_expr -> cond_for .)
    RETURN          reduce using rule 67 (loop_cond_expr -> cond_for .)
    PRINT           reduce using rule 67 (loop_cond_expr -> cond_for .)
    {               reduce using rule 67 (loop_cond_expr -> cond_for .)
    ID              reduce using rule 67 (loop_cond_expr -> cond_for .)
    IF              reduce using rule 67 (loop_cond_expr -> cond_for .)
    WHILE           reduce using rule 67 (loop_cond_expr -> cond_for .)
    FOR             reduce using rule 67 (loop_cond_expr -> cond_for .)
    $end            reduce using rule 67 (loop_cond_expr -> cond_for .)
    }               reduce using rule 67 (loop_cond_expr -> cond_for .)
    ELSE            reduce using rule 67 (loop_cond_expr -> cond_for .)
    BREAK           reduce using rule 67 (loop_cond_expr -> cond_for .)
    CONTINUE        reduce using rule 67 (loop_cond_expr -> cond_for .)


state 122

    (11) loop_block -> { . loop_block_interior }
    (15) loop_block_interior -> . loop_block_interior expr ;
    (16) loop_block_interior -> . loop_block_interior loop_instruction ;
    (17) loop_block_interior -> . loop_block_interior loop_cond_expr
    (18) loop_block_interior -> . expr ;
    (19) loop_block_interior -> . loop_instruction ;
    (20) loop_block_interior -> . loop_cond_expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    ID              shift and go to state 25
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    loop_block_interior            shift and go to state 131
    expr                           shift and go to state 132
    loop_instruction               shift and go to state 133
    loop_cond_expr                 shift and go to state 134
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    instruction                    shift and go to state 125
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121

state 123

    (74) loop_instruction -> BREAK .

    ;               reduce using rule 74 (loop_instruction -> BREAK .)


state 124

    (75) loop_instruction -> CONTINUE .

    ;               reduce using rule 75 (loop_instruction -> CONTINUE .)


state 125

    (76) loop_instruction -> instruction .

    ;               reduce using rule 76 (loop_instruction -> instruction .)


state 126

    (40) assignment -> lvalue . = expr
    (41) assignment -> lvalue . PLUSASSIGN expr
    (42) assignment -> lvalue . MINASSIGN expr
    (43) assignment -> lvalue . MULTASSIGN expr
    (44) assignment -> lvalue . DIVASSIGN expr

    =               shift and go to state 51
    PLUSASSIGN      shift and go to state 52
    MINASSIGN       shift and go to state 53
    MULTASSIGN      shift and go to state 54
    DIVASSIGN       shift and go to state 55


state 127

    (68) loop_cond_if -> IF . ( expr ) loop_struct
    (69) loop_cond_if -> IF . ( expr ) loop_struct ELSE loop_struct

    (               shift and go to state 135


state 128

    (71) cond_for -> FOR lvalue = range loop_struct .

    INTNUM          reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    FLOATNUM        reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    STRING          reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    ZEROS           reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    ONES            reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    EYE             reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    (               reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    -               reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    [               reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    RETURN          reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    PRINT           reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    {               reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    ID              reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    IF              reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    WHILE           reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    FOR             reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    $end            reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    }               reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    ELSE            reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    BREAK           reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)
    CONTINUE        reduce using rule 71 (cond_for -> FOR lvalue = range loop_struct .)


state 129

    (64) cond_if -> IF ( expr ) struct ELSE . struct
    (5) struct -> . expr ;
    (6) struct -> . instruction ;
    (7) struct -> . cond_expr
    (8) struct -> . block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (60) cond_expr -> . cond_if
    (61) cond_expr -> . cond_while
    (62) cond_expr -> . cond_for
    (4) block -> . { block_interior }
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (63) cond_if -> . IF ( expr ) struct
    (64) cond_if -> . IF ( expr ) struct ELSE struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    {               shift and go to state 24
    ID              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    expr                           shift and go to state 4
    struct                         shift and go to state 136
    instruction                    shift and go to state 5
    cond_expr                      shift and go to state 6
    block                          shift and go to state 7
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    cond_if                        shift and go to state 21
    cond_while                     shift and go to state 22
    cond_for                       shift and go to state 23

state 130

    (12) loop_struct -> loop_single_stmt ; .

    INTNUM          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    FLOATNUM        reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    STRING          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ZEROS           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ONES            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    EYE             reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    (               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    -               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    [               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    RETURN          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    PRINT           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    {               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ID              reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    IF              reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    WHILE           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    FOR             reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    $end            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    }               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ELSE            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    BREAK           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    CONTINUE        reduce using rule 12 (loop_struct -> loop_single_stmt ; .)


state 131

    (11) loop_block -> { loop_block_interior . }
    (15) loop_block_interior -> loop_block_interior . expr ;
    (16) loop_block_interior -> loop_block_interior . loop_instruction ;
    (17) loop_block_interior -> loop_block_interior . loop_cond_expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct

    }               shift and go to state 137
    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    ID              shift and go to state 25
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28

    expr                           shift and go to state 138
    loop_instruction               shift and go to state 139
    loop_cond_expr                 shift and go to state 140
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18
    instruction                    shift and go to state 125
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121

state 132

    (18) loop_block_interior -> expr . ;
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               shift and go to state 141
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 133

    (19) loop_block_interior -> loop_instruction . ;

    ;               shift and go to state 142


state 134

    (20) loop_block_interior -> loop_cond_expr .

    }               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    INTNUM          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    FLOATNUM        reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    STRING          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ZEROS           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ONES            reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    EYE             reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    (               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    -               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    [               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    BREAK           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    CONTINUE        reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ID              reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    RETURN          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    PRINT           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    IF              reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    WHILE           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    FOR             reduce using rule 20 (loop_block_interior -> loop_cond_expr .)


state 135

    (68) loop_cond_if -> IF ( . expr ) loop_struct
    (69) loop_cond_if -> IF ( . expr ) loop_struct ELSE loop_struct
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (36) expr -> . [ array_interior ]
    (45) expr -> . assignment
    (46) expr -> . expr + expr
    (47) expr -> . expr - expr
    (48) expr -> . expr * expr
    (49) expr -> . expr / expr
    (50) expr -> . expr MPLUS expr
    (51) expr -> . expr MMINUS expr
    (52) expr -> . expr MMLTP expr
    (53) expr -> . expr MDIV expr
    (54) expr -> . expr EQ expr
    (55) expr -> . expr NEQ expr
    (56) expr -> . expr GTEQ expr
    (57) expr -> . expr LTEQ expr
    (58) expr -> . expr > expr
    (59) expr -> . expr < expr
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 8
    FLOATNUM        shift and go to state 9
    STRING          shift and go to state 10
    ZEROS           shift and go to state 11
    ONES            shift and go to state 13
    EYE             shift and go to state 14
    (               shift and go to state 12
    -               shift and go to state 16
    [               shift and go to state 17
    ID              shift and go to state 25

    expr                           shift and go to state 143
    lvalue                         shift and go to state 15
    assignment                     shift and go to state 18

state 136

    (64) cond_if -> IF ( expr ) struct ELSE struct .

    INTNUM          reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    FLOATNUM        reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    STRING          reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    ZEROS           reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    ONES            reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    EYE             reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    (               reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    -               reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    [               reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    RETURN          reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    PRINT           reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    {               reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    ID              reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    IF              reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    WHILE           reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    FOR             reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    $end            reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    }               reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)
    ELSE            reduce using rule 64 (cond_if -> IF ( expr ) struct ELSE struct .)


state 137

    (11) loop_block -> { loop_block_interior } .

    INTNUM          reduce using rule 11 (loop_block -> { loop_block_interior } .)
    FLOATNUM        reduce using rule 11 (loop_block -> { loop_block_interior } .)
    STRING          reduce using rule 11 (loop_block -> { loop_block_interior } .)
    ZEROS           reduce using rule 11 (loop_block -> { loop_block_interior } .)
    ONES            reduce using rule 11 (loop_block -> { loop_block_interior } .)
    EYE             reduce using rule 11 (loop_block -> { loop_block_interior } .)
    (               reduce using rule 11 (loop_block -> { loop_block_interior } .)
    -               reduce using rule 11 (loop_block -> { loop_block_interior } .)
    [               reduce using rule 11 (loop_block -> { loop_block_interior } .)
    RETURN          reduce using rule 11 (loop_block -> { loop_block_interior } .)
    PRINT           reduce using rule 11 (loop_block -> { loop_block_interior } .)
    {               reduce using rule 11 (loop_block -> { loop_block_interior } .)
    ID              reduce using rule 11 (loop_block -> { loop_block_interior } .)
    IF              reduce using rule 11 (loop_block -> { loop_block_interior } .)
    WHILE           reduce using rule 11 (loop_block -> { loop_block_interior } .)
    FOR             reduce using rule 11 (loop_block -> { loop_block_interior } .)
    $end            reduce using rule 11 (loop_block -> { loop_block_interior } .)
    }               reduce using rule 11 (loop_block -> { loop_block_interior } .)
    ELSE            reduce using rule 11 (loop_block -> { loop_block_interior } .)
    BREAK           reduce using rule 11 (loop_block -> { loop_block_interior } .)
    CONTINUE        reduce using rule 11 (loop_block -> { loop_block_interior } .)


state 138

    (15) loop_block_interior -> loop_block_interior expr . ;
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    ;               shift and go to state 144
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 139

    (16) loop_block_interior -> loop_block_interior loop_instruction . ;

    ;               shift and go to state 145


state 140

    (17) loop_block_interior -> loop_block_interior loop_cond_expr .

    }               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    INTNUM          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    FLOATNUM        reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    STRING          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ZEROS           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ONES            reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    EYE             reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    (               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    -               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    [               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    BREAK           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    CONTINUE        reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ID              reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    RETURN          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    PRINT           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    IF              reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    WHILE           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    FOR             reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)


state 141

    (18) loop_block_interior -> expr ; .

    }               reduce using rule 18 (loop_block_interior -> expr ; .)
    INTNUM          reduce using rule 18 (loop_block_interior -> expr ; .)
    FLOATNUM        reduce using rule 18 (loop_block_interior -> expr ; .)
    STRING          reduce using rule 18 (loop_block_interior -> expr ; .)
    ZEROS           reduce using rule 18 (loop_block_interior -> expr ; .)
    ONES            reduce using rule 18 (loop_block_interior -> expr ; .)
    EYE             reduce using rule 18 (loop_block_interior -> expr ; .)
    (               reduce using rule 18 (loop_block_interior -> expr ; .)
    -               reduce using rule 18 (loop_block_interior -> expr ; .)
    [               reduce using rule 18 (loop_block_interior -> expr ; .)
    BREAK           reduce using rule 18 (loop_block_interior -> expr ; .)
    CONTINUE        reduce using rule 18 (loop_block_interior -> expr ; .)
    ID              reduce using rule 18 (loop_block_interior -> expr ; .)
    RETURN          reduce using rule 18 (loop_block_interior -> expr ; .)
    PRINT           reduce using rule 18 (loop_block_interior -> expr ; .)
    IF              reduce using rule 18 (loop_block_interior -> expr ; .)
    WHILE           reduce using rule 18 (loop_block_interior -> expr ; .)
    FOR             reduce using rule 18 (loop_block_interior -> expr ; .)


state 142

    (19) loop_block_interior -> loop_instruction ; .

    }               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    INTNUM          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    FLOATNUM        reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    STRING          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ZEROS           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ONES            reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    EYE             reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    (               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    -               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    [               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    BREAK           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    CONTINUE        reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ID              reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    RETURN          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    PRINT           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    IF              reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    WHILE           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    FOR             reduce using rule 19 (loop_block_interior -> loop_instruction ; .)


state 143

    (68) loop_cond_if -> IF ( expr . ) loop_struct
    (69) loop_cond_if -> IF ( expr . ) loop_struct ELSE loop_struct
    (32) expr -> expr . '
    (46) expr -> expr . + expr
    (47) expr -> expr . - expr
    (48) expr -> expr . * expr
    (49) expr -> expr . / expr
    (50) expr -> expr . MPLUS expr
    (51) expr -> expr . MMINUS expr
    (52) expr -> expr . MMLTP expr
    (53) expr -> expr . MDIV expr
    (54) expr -> expr . EQ expr
    (55) expr -> expr . NEQ expr
    (56) expr -> expr . GTEQ expr
    (57) expr -> expr . LTEQ expr
    (58) expr -> expr . > expr
    (59) expr -> expr . < expr

    )               shift and go to state 146
    '               shift and go to state 31
    +               shift and go to state 32
    -               shift and go to state 33
    *               shift and go to state 34
    /               shift and go to state 35
    MPLUS           shift and go to state 36
    MMINUS          shift and go to state 37
    MMLTP           shift and go to state 38
    MDIV            shift and go to state 39
    EQ              shift and go to state 40
    NEQ             shift and go to state 41
    GTEQ            shift and go to state 42
    LTEQ            shift and go to state 43
    >               shift and go to state 44
    <               shift and go to state 45


state 144

    (15) loop_block_interior -> loop_block_interior expr ; .

    }               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    INTNUM          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    FLOATNUM        reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    STRING          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ZEROS           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ONES            reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    EYE             reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    (               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    -               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    [               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    BREAK           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    CONTINUE        reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ID              reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    RETURN          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    PRINT           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    IF              reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    WHILE           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    FOR             reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)


state 145

    (16) loop_block_interior -> loop_block_interior loop_instruction ; .

    }               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    INTNUM          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    FLOATNUM        reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    STRING          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ZEROS           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ONES            reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    EYE             reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    (               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    -               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    [               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    BREAK           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    CONTINUE        reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ID              reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    RETURN          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    PRINT           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    IF              reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    WHILE           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    FOR             reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)


state 146

    (68) loop_cond_if -> IF ( expr ) . loop_struct
    (69) loop_cond_if -> IF ( expr ) . loop_struct ELSE loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . loop_block
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (11) loop_block -> . { loop_block_interior }
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]

    {               shift and go to state 122
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    ID              shift and go to state 25

    loop_struct                    shift and go to state 147
    loop_single_stmt               shift and go to state 114
    loop_cond_expr                 shift and go to state 115
    loop_block                     shift and go to state 116
    loop_instruction               shift and go to state 117
    assignment                     shift and go to state 118
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121
    instruction                    shift and go to state 125
    lvalue                         shift and go to state 126

state 147

    (68) loop_cond_if -> IF ( expr ) loop_struct .
    (69) loop_cond_if -> IF ( expr ) loop_struct . ELSE loop_struct

    INTNUM          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    FLOATNUM        reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    STRING          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    ZEROS           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    ONES            reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    EYE             reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    (               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    -               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    [               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    RETURN          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    PRINT           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    {               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    ID              reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    IF              reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    WHILE           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    FOR             reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    $end            reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    }               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    BREAK           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    CONTINUE        reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .)
    ELSE            shift and go to state 148

  ! ELSE            [ reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_struct .) ]


state 148

    (69) loop_cond_if -> IF ( expr ) loop_struct ELSE . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . loop_block
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (65) loop_cond_expr -> . loop_cond_if
    (66) loop_cond_expr -> . cond_while
    (67) loop_cond_expr -> . cond_for
    (11) loop_block -> . { loop_block_interior }
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . instruction
    (40) assignment -> . lvalue = expr
    (41) assignment -> . lvalue PLUSASSIGN expr
    (42) assignment -> . lvalue MINASSIGN expr
    (43) assignment -> . lvalue MULTASSIGN expr
    (44) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_struct
    (69) loop_cond_if -> . IF ( expr ) loop_struct ELSE loop_struct
    (70) cond_while -> . WHILE ( expr ) loop_struct
    (71) cond_for -> . FOR lvalue = range loop_struct
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (37) lvalue -> . ID
    (38) lvalue -> . ID [ array_interior ]
    (39) lvalue -> . ID [ range ]

    {               shift and go to state 122
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    IF              shift and go to state 127
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    RETURN          shift and go to state 19
    PRINT           shift and go to state 20
    ID              shift and go to state 25

    loop_struct                    shift and go to state 149
    loop_single_stmt               shift and go to state 114
    loop_cond_expr                 shift and go to state 115
    loop_block                     shift and go to state 116
    loop_instruction               shift and go to state 117
    assignment                     shift and go to state 118
    loop_cond_if                   shift and go to state 119
    cond_while                     shift and go to state 120
    cond_for                       shift and go to state 121
    instruction                    shift and go to state 125
    lvalue                         shift and go to state 126

state 149

    (69) loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .

    INTNUM          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    FLOATNUM        reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    STRING          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    ZEROS           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    ONES            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    EYE             reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    (               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    -               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    [               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    RETURN          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    PRINT           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    {               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    ID              reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    IF              reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    WHILE           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    FOR             reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    $end            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    }               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    ELSE            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    BREAK           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)
    CONTINUE        reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_struct ELSE loop_struct .)

