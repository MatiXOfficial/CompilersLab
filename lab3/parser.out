Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> struct
Rule 2     start -> start struct
Rule 3     struct -> single_stmt ;
Rule 4     struct -> cond_expr
Rule 5     struct -> { block_interior }
Rule 6     block_interior -> block_interior expr ;
Rule 7     block_interior -> block_interior instruction ;
Rule 8     block_interior -> expr ;
Rule 9     block_interior -> instruction ;
Rule 10    single_stmt -> instruction
Rule 11    single_stmt -> assignment
Rule 12    loop_struct -> loop_single_stmt ;
Rule 13    loop_struct -> loop_cond_expr
Rule 14    loop_struct -> { loop_block_interior }
Rule 15    loop_block_interior -> loop_block_interior expr ;
Rule 16    loop_block_interior -> loop_block_interior loop_instruction ;
Rule 17    loop_block_interior -> loop_block_interior loop_cond_expr
Rule 18    loop_block_interior -> expr ;
Rule 19    loop_block_interior -> loop_instruction ;
Rule 20    loop_block_interior -> loop_cond_expr
Rule 21    loop_single_stmt -> loop_instruction
Rule 22    loop_single_stmt -> assignment
Rule 23    expr -> INTNUM
Rule 24    expr -> FLOATNUM
Rule 25    expr -> STRING
Rule 26    expr -> ZEROS ( expr )
Rule 27    expr -> ONES ( expr )
Rule 28    expr -> EYE ( expr )
Rule 29    expr -> lvalue
Rule 30    expr -> ( expr )
Rule 31    expr -> - expr
Rule 32    expr -> expr '
Rule 33    array_interior -> array_interior , expr
Rule 34    array_interior -> expr
Rule 35    expr -> [ array_interior ]
Rule 36    lvalue -> ID
Rule 37    lvalue -> ID [ array_interior ]
Rule 38    assignment -> lvalue = expr
Rule 39    assignment -> lvalue PLUSASSIGN expr
Rule 40    assignment -> lvalue MINASSIGN expr
Rule 41    assignment -> lvalue MULTASSIGN expr
Rule 42    assignment -> lvalue DIVASSIGN expr
Rule 43    expr -> assignment
Rule 44    expr -> expr + expr
Rule 45    expr -> expr - expr
Rule 46    expr -> expr * expr
Rule 47    expr -> expr / expr
Rule 48    expr -> expr MPLUS expr
Rule 49    expr -> expr MMINUS expr
Rule 50    expr -> expr MMLTP expr
Rule 51    expr -> expr MDIV expr
Rule 52    expr -> expr EQ expr
Rule 53    expr -> expr NEQ expr
Rule 54    expr -> expr GTEQ expr
Rule 55    expr -> expr LTEQ expr
Rule 56    expr -> expr > expr
Rule 57    expr -> expr < expr
Rule 58    cond_expr -> cond_if
Rule 59    cond_expr -> cond_while
Rule 60    cond_expr -> cond_for
Rule 61    cond_block -> struct
Rule 62    cond_if -> IF ( expr ) cond_block
Rule 63    cond_if -> IF ( expr ) cond_block ELSE cond_block
Rule 64    loop_cond_expr -> loop_cond_if
Rule 65    loop_cond_expr -> cond_while
Rule 66    loop_cond_expr -> cond_for
Rule 67    loop_cond_block -> loop_struct
Rule 68    loop_cond_if -> IF ( expr ) loop_cond_block
Rule 69    loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block
Rule 70    cond_while -> WHILE ( expr ) loop_cond_block
Rule 71    cond_for -> FOR ID = expr : expr loop_cond_block
Rule 72    instruction -> RETURN expr
Rule 73    instruction -> PRINT array_interior
Rule 74    loop_instruction -> BREAK
Rule 75    loop_instruction -> CONTINUE
Rule 76    loop_instruction -> RETURN expr
Rule 77    loop_instruction -> PRINT array_interior

Terminals, with rules where they appear

'                    : 32
(                    : 26 27 28 30 62 63 68 69 70
)                    : 26 27 28 30 62 63 68 69 70
*                    : 46
+                    : 44
,                    : 33
-                    : 31 45
/                    : 47
:                    : 71
;                    : 3 6 7 8 9 12 15 16 18 19
<                    : 57
=                    : 38 71
>                    : 56
BREAK                : 74
CONTINUE             : 75
DIVASSIGN            : 42
ELSE                 : 63 69
EQ                   : 52
EYE                  : 28
FLOATNUM             : 24
FOR                  : 71
GTEQ                 : 54
ID                   : 36 37 71
IF                   : 62 63 68 69
INTNUM               : 23
LTEQ                 : 55
MDIV                 : 51
MINASSIGN            : 40
MMINUS               : 49
MMLTP                : 50
MPLUS                : 48
MULTASSIGN           : 41
NEQ                  : 53
ONES                 : 27
PLUSASSIGN           : 39
PRINT                : 73 77
RETURN               : 72 76
STRING               : 25
WHILE                : 70
ZEROS                : 26
[                    : 35 37
]                    : 35 37
error                : 
{                    : 5 14
}                    : 5 14

Nonterminals, with rules where they appear

array_interior       : 33 35 37 73 77
assignment           : 11 22 43
block_interior       : 5 6 7
cond_block           : 62 63 63
cond_expr            : 4
cond_for             : 60 66
cond_if              : 58
cond_while           : 59 65
expr                 : 6 8 15 18 26 27 28 30 31 32 33 34 38 39 40 41 42 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 62 63 68 69 70 71 71 72 76
instruction          : 7 9 10
loop_block_interior  : 14 15 16 17
loop_cond_block      : 68 69 69 70 71
loop_cond_expr       : 13 17 20
loop_cond_if         : 64
loop_instruction     : 16 19 21
loop_single_stmt     : 12
loop_struct          : 67
lvalue               : 29 38 39 40 41 42
single_stmt          : 3
start                : 2 0
struct               : 1 2 61

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . struct
    (2) start -> . start struct
    (3) struct -> . single_stmt ;
    (4) struct -> . cond_expr
    (5) struct -> . { block_interior }
    (10) single_stmt -> . instruction
    (11) single_stmt -> . assignment
    (58) cond_expr -> . cond_if
    (59) cond_expr -> . cond_while
    (60) cond_expr -> . cond_for
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (62) cond_if -> . IF ( expr ) cond_block
    (63) cond_if -> . IF ( expr ) cond_block ELSE cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 5
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    start                          shift and go to state 1
    struct                         shift and go to state 2
    single_stmt                    shift and go to state 3
    cond_expr                      shift and go to state 4
    instruction                    shift and go to state 6
    assignment                     shift and go to state 7
    cond_if                        shift and go to state 8
    cond_while                     shift and go to state 9
    cond_for                       shift and go to state 10
    lvalue                         shift and go to state 13

state 1

    (0) S' -> start .
    (2) start -> start . struct
    (3) struct -> . single_stmt ;
    (4) struct -> . cond_expr
    (5) struct -> . { block_interior }
    (10) single_stmt -> . instruction
    (11) single_stmt -> . assignment
    (58) cond_expr -> . cond_if
    (59) cond_expr -> . cond_while
    (60) cond_expr -> . cond_for
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (62) cond_if -> . IF ( expr ) cond_block
    (63) cond_if -> . IF ( expr ) cond_block ELSE cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 5
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    struct                         shift and go to state 18
    single_stmt                    shift and go to state 3
    cond_expr                      shift and go to state 4
    instruction                    shift and go to state 6
    assignment                     shift and go to state 7
    cond_if                        shift and go to state 8
    cond_while                     shift and go to state 9
    cond_for                       shift and go to state 10
    lvalue                         shift and go to state 13

state 2

    (1) start -> struct .

    {               reduce using rule 1 (start -> struct .)
    RETURN          reduce using rule 1 (start -> struct .)
    PRINT           reduce using rule 1 (start -> struct .)
    IF              reduce using rule 1 (start -> struct .)
    WHILE           reduce using rule 1 (start -> struct .)
    FOR             reduce using rule 1 (start -> struct .)
    ID              reduce using rule 1 (start -> struct .)
    $end            reduce using rule 1 (start -> struct .)


state 3

    (3) struct -> single_stmt . ;

    ;               shift and go to state 19


state 4

    (4) struct -> cond_expr .

    {               reduce using rule 4 (struct -> cond_expr .)
    RETURN          reduce using rule 4 (struct -> cond_expr .)
    PRINT           reduce using rule 4 (struct -> cond_expr .)
    IF              reduce using rule 4 (struct -> cond_expr .)
    WHILE           reduce using rule 4 (struct -> cond_expr .)
    FOR             reduce using rule 4 (struct -> cond_expr .)
    ID              reduce using rule 4 (struct -> cond_expr .)
    $end            reduce using rule 4 (struct -> cond_expr .)
    ELSE            reduce using rule 4 (struct -> cond_expr .)


state 5

    (5) struct -> { . block_interior }
    (6) block_interior -> . block_interior expr ;
    (7) block_interior -> . block_interior instruction ;
    (8) block_interior -> . expr ;
    (9) block_interior -> . instruction ;
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    ID              shift and go to state 17

    block_interior                 shift and go to state 20
    expr                           shift and go to state 21
    instruction                    shift and go to state 22
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 6

    (10) single_stmt -> instruction .

    ;               reduce using rule 10 (single_stmt -> instruction .)


state 7

    (11) single_stmt -> assignment .

    ;               reduce using rule 11 (single_stmt -> assignment .)


state 8

    (58) cond_expr -> cond_if .

    {               reduce using rule 58 (cond_expr -> cond_if .)
    RETURN          reduce using rule 58 (cond_expr -> cond_if .)
    PRINT           reduce using rule 58 (cond_expr -> cond_if .)
    IF              reduce using rule 58 (cond_expr -> cond_if .)
    WHILE           reduce using rule 58 (cond_expr -> cond_if .)
    FOR             reduce using rule 58 (cond_expr -> cond_if .)
    ID              reduce using rule 58 (cond_expr -> cond_if .)
    $end            reduce using rule 58 (cond_expr -> cond_if .)
    ELSE            reduce using rule 58 (cond_expr -> cond_if .)


state 9

    (59) cond_expr -> cond_while .

    {               reduce using rule 59 (cond_expr -> cond_while .)
    RETURN          reduce using rule 59 (cond_expr -> cond_while .)
    PRINT           reduce using rule 59 (cond_expr -> cond_while .)
    IF              reduce using rule 59 (cond_expr -> cond_while .)
    WHILE           reduce using rule 59 (cond_expr -> cond_while .)
    FOR             reduce using rule 59 (cond_expr -> cond_while .)
    ID              reduce using rule 59 (cond_expr -> cond_while .)
    $end            reduce using rule 59 (cond_expr -> cond_while .)
    ELSE            reduce using rule 59 (cond_expr -> cond_while .)


state 10

    (60) cond_expr -> cond_for .

    {               reduce using rule 60 (cond_expr -> cond_for .)
    RETURN          reduce using rule 60 (cond_expr -> cond_for .)
    PRINT           reduce using rule 60 (cond_expr -> cond_for .)
    IF              reduce using rule 60 (cond_expr -> cond_for .)
    WHILE           reduce using rule 60 (cond_expr -> cond_for .)
    FOR             reduce using rule 60 (cond_expr -> cond_for .)
    ID              reduce using rule 60 (cond_expr -> cond_for .)
    $end            reduce using rule 60 (cond_expr -> cond_for .)
    ELSE            reduce using rule 60 (cond_expr -> cond_for .)


state 11

    (72) instruction -> RETURN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 34
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 12

    (73) instruction -> PRINT . array_interior
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    array_interior                 shift and go to state 35
    expr                           shift and go to state 36
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 13

    (38) assignment -> lvalue . = expr
    (39) assignment -> lvalue . PLUSASSIGN expr
    (40) assignment -> lvalue . MINASSIGN expr
    (41) assignment -> lvalue . MULTASSIGN expr
    (42) assignment -> lvalue . DIVASSIGN expr

    =               shift and go to state 37
    PLUSASSIGN      shift and go to state 38
    MINASSIGN       shift and go to state 39
    MULTASSIGN      shift and go to state 40
    DIVASSIGN       shift and go to state 41


state 14

    (62) cond_if -> IF . ( expr ) cond_block
    (63) cond_if -> IF . ( expr ) cond_block ELSE cond_block

    (               shift and go to state 42


state 15

    (70) cond_while -> WHILE . ( expr ) loop_cond_block

    (               shift and go to state 43


state 16

    (71) cond_for -> FOR . ID = expr : expr loop_cond_block

    ID              shift and go to state 44


state 17

    (36) lvalue -> ID .
    (37) lvalue -> ID . [ array_interior ]

    =               reduce using rule 36 (lvalue -> ID .)
    PLUSASSIGN      reduce using rule 36 (lvalue -> ID .)
    MINASSIGN       reduce using rule 36 (lvalue -> ID .)
    MULTASSIGN      reduce using rule 36 (lvalue -> ID .)
    DIVASSIGN       reduce using rule 36 (lvalue -> ID .)
    ;               reduce using rule 36 (lvalue -> ID .)
    '               reduce using rule 36 (lvalue -> ID .)
    +               reduce using rule 36 (lvalue -> ID .)
    -               reduce using rule 36 (lvalue -> ID .)
    *               reduce using rule 36 (lvalue -> ID .)
    /               reduce using rule 36 (lvalue -> ID .)
    MPLUS           reduce using rule 36 (lvalue -> ID .)
    MMINUS          reduce using rule 36 (lvalue -> ID .)
    MMLTP           reduce using rule 36 (lvalue -> ID .)
    MDIV            reduce using rule 36 (lvalue -> ID .)
    EQ              reduce using rule 36 (lvalue -> ID .)
    NEQ             reduce using rule 36 (lvalue -> ID .)
    GTEQ            reduce using rule 36 (lvalue -> ID .)
    LTEQ            reduce using rule 36 (lvalue -> ID .)
    >               reduce using rule 36 (lvalue -> ID .)
    <               reduce using rule 36 (lvalue -> ID .)
    ,               reduce using rule 36 (lvalue -> ID .)
    )               reduce using rule 36 (lvalue -> ID .)
    ]               reduce using rule 36 (lvalue -> ID .)
    :               reduce using rule 36 (lvalue -> ID .)
    {               reduce using rule 36 (lvalue -> ID .)
    BREAK           reduce using rule 36 (lvalue -> ID .)
    CONTINUE        reduce using rule 36 (lvalue -> ID .)
    RETURN          reduce using rule 36 (lvalue -> ID .)
    PRINT           reduce using rule 36 (lvalue -> ID .)
    IF              reduce using rule 36 (lvalue -> ID .)
    WHILE           reduce using rule 36 (lvalue -> ID .)
    FOR             reduce using rule 36 (lvalue -> ID .)
    ID              reduce using rule 36 (lvalue -> ID .)
    [               shift and go to state 45


state 18

    (2) start -> start struct .

    {               reduce using rule 2 (start -> start struct .)
    RETURN          reduce using rule 2 (start -> start struct .)
    PRINT           reduce using rule 2 (start -> start struct .)
    IF              reduce using rule 2 (start -> start struct .)
    WHILE           reduce using rule 2 (start -> start struct .)
    FOR             reduce using rule 2 (start -> start struct .)
    ID              reduce using rule 2 (start -> start struct .)
    $end            reduce using rule 2 (start -> start struct .)


state 19

    (3) struct -> single_stmt ; .

    {               reduce using rule 3 (struct -> single_stmt ; .)
    RETURN          reduce using rule 3 (struct -> single_stmt ; .)
    PRINT           reduce using rule 3 (struct -> single_stmt ; .)
    IF              reduce using rule 3 (struct -> single_stmt ; .)
    WHILE           reduce using rule 3 (struct -> single_stmt ; .)
    FOR             reduce using rule 3 (struct -> single_stmt ; .)
    ID              reduce using rule 3 (struct -> single_stmt ; .)
    $end            reduce using rule 3 (struct -> single_stmt ; .)
    ELSE            reduce using rule 3 (struct -> single_stmt ; .)


state 20

    (5) struct -> { block_interior . }
    (6) block_interior -> block_interior . expr ;
    (7) block_interior -> block_interior . instruction ;
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    }               shift and go to state 46
    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    ID              shift and go to state 17

    expr                           shift and go to state 47
    instruction                    shift and go to state 48
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 21

    (8) block_interior -> expr . ;
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               shift and go to state 49
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 22

    (9) block_interior -> instruction . ;

    ;               shift and go to state 65


state 23

    (23) expr -> INTNUM .

    ;               reduce using rule 23 (expr -> INTNUM .)
    '               reduce using rule 23 (expr -> INTNUM .)
    +               reduce using rule 23 (expr -> INTNUM .)
    -               reduce using rule 23 (expr -> INTNUM .)
    *               reduce using rule 23 (expr -> INTNUM .)
    /               reduce using rule 23 (expr -> INTNUM .)
    MPLUS           reduce using rule 23 (expr -> INTNUM .)
    MMINUS          reduce using rule 23 (expr -> INTNUM .)
    MMLTP           reduce using rule 23 (expr -> INTNUM .)
    MDIV            reduce using rule 23 (expr -> INTNUM .)
    EQ              reduce using rule 23 (expr -> INTNUM .)
    NEQ             reduce using rule 23 (expr -> INTNUM .)
    GTEQ            reduce using rule 23 (expr -> INTNUM .)
    LTEQ            reduce using rule 23 (expr -> INTNUM .)
    >               reduce using rule 23 (expr -> INTNUM .)
    <               reduce using rule 23 (expr -> INTNUM .)
    ,               reduce using rule 23 (expr -> INTNUM .)
    )               reduce using rule 23 (expr -> INTNUM .)
    ]               reduce using rule 23 (expr -> INTNUM .)
    :               reduce using rule 23 (expr -> INTNUM .)
    {               reduce using rule 23 (expr -> INTNUM .)
    BREAK           reduce using rule 23 (expr -> INTNUM .)
    CONTINUE        reduce using rule 23 (expr -> INTNUM .)
    RETURN          reduce using rule 23 (expr -> INTNUM .)
    PRINT           reduce using rule 23 (expr -> INTNUM .)
    IF              reduce using rule 23 (expr -> INTNUM .)
    WHILE           reduce using rule 23 (expr -> INTNUM .)
    FOR             reduce using rule 23 (expr -> INTNUM .)
    ID              reduce using rule 23 (expr -> INTNUM .)


state 24

    (24) expr -> FLOATNUM .

    ;               reduce using rule 24 (expr -> FLOATNUM .)
    '               reduce using rule 24 (expr -> FLOATNUM .)
    +               reduce using rule 24 (expr -> FLOATNUM .)
    -               reduce using rule 24 (expr -> FLOATNUM .)
    *               reduce using rule 24 (expr -> FLOATNUM .)
    /               reduce using rule 24 (expr -> FLOATNUM .)
    MPLUS           reduce using rule 24 (expr -> FLOATNUM .)
    MMINUS          reduce using rule 24 (expr -> FLOATNUM .)
    MMLTP           reduce using rule 24 (expr -> FLOATNUM .)
    MDIV            reduce using rule 24 (expr -> FLOATNUM .)
    EQ              reduce using rule 24 (expr -> FLOATNUM .)
    NEQ             reduce using rule 24 (expr -> FLOATNUM .)
    GTEQ            reduce using rule 24 (expr -> FLOATNUM .)
    LTEQ            reduce using rule 24 (expr -> FLOATNUM .)
    >               reduce using rule 24 (expr -> FLOATNUM .)
    <               reduce using rule 24 (expr -> FLOATNUM .)
    ,               reduce using rule 24 (expr -> FLOATNUM .)
    )               reduce using rule 24 (expr -> FLOATNUM .)
    ]               reduce using rule 24 (expr -> FLOATNUM .)
    :               reduce using rule 24 (expr -> FLOATNUM .)
    {               reduce using rule 24 (expr -> FLOATNUM .)
    BREAK           reduce using rule 24 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 24 (expr -> FLOATNUM .)
    RETURN          reduce using rule 24 (expr -> FLOATNUM .)
    PRINT           reduce using rule 24 (expr -> FLOATNUM .)
    IF              reduce using rule 24 (expr -> FLOATNUM .)
    WHILE           reduce using rule 24 (expr -> FLOATNUM .)
    FOR             reduce using rule 24 (expr -> FLOATNUM .)
    ID              reduce using rule 24 (expr -> FLOATNUM .)


state 25

    (25) expr -> STRING .

    ;               reduce using rule 25 (expr -> STRING .)
    '               reduce using rule 25 (expr -> STRING .)
    +               reduce using rule 25 (expr -> STRING .)
    -               reduce using rule 25 (expr -> STRING .)
    *               reduce using rule 25 (expr -> STRING .)
    /               reduce using rule 25 (expr -> STRING .)
    MPLUS           reduce using rule 25 (expr -> STRING .)
    MMINUS          reduce using rule 25 (expr -> STRING .)
    MMLTP           reduce using rule 25 (expr -> STRING .)
    MDIV            reduce using rule 25 (expr -> STRING .)
    EQ              reduce using rule 25 (expr -> STRING .)
    NEQ             reduce using rule 25 (expr -> STRING .)
    GTEQ            reduce using rule 25 (expr -> STRING .)
    LTEQ            reduce using rule 25 (expr -> STRING .)
    >               reduce using rule 25 (expr -> STRING .)
    <               reduce using rule 25 (expr -> STRING .)
    ,               reduce using rule 25 (expr -> STRING .)
    )               reduce using rule 25 (expr -> STRING .)
    ]               reduce using rule 25 (expr -> STRING .)
    :               reduce using rule 25 (expr -> STRING .)
    {               reduce using rule 25 (expr -> STRING .)
    BREAK           reduce using rule 25 (expr -> STRING .)
    CONTINUE        reduce using rule 25 (expr -> STRING .)
    RETURN          reduce using rule 25 (expr -> STRING .)
    PRINT           reduce using rule 25 (expr -> STRING .)
    IF              reduce using rule 25 (expr -> STRING .)
    WHILE           reduce using rule 25 (expr -> STRING .)
    FOR             reduce using rule 25 (expr -> STRING .)
    ID              reduce using rule 25 (expr -> STRING .)


state 26

    (26) expr -> ZEROS . ( expr )

    (               shift and go to state 66


state 27

    (30) expr -> ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 67
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 28

    (27) expr -> ONES . ( expr )

    (               shift and go to state 68


state 29

    (28) expr -> EYE . ( expr )

    (               shift and go to state 69


state 30

    (29) expr -> lvalue .
    (38) assignment -> lvalue . = expr
    (39) assignment -> lvalue . PLUSASSIGN expr
    (40) assignment -> lvalue . MINASSIGN expr
    (41) assignment -> lvalue . MULTASSIGN expr
    (42) assignment -> lvalue . DIVASSIGN expr

    ;               reduce using rule 29 (expr -> lvalue .)
    '               reduce using rule 29 (expr -> lvalue .)
    +               reduce using rule 29 (expr -> lvalue .)
    -               reduce using rule 29 (expr -> lvalue .)
    *               reduce using rule 29 (expr -> lvalue .)
    /               reduce using rule 29 (expr -> lvalue .)
    MPLUS           reduce using rule 29 (expr -> lvalue .)
    MMINUS          reduce using rule 29 (expr -> lvalue .)
    MMLTP           reduce using rule 29 (expr -> lvalue .)
    MDIV            reduce using rule 29 (expr -> lvalue .)
    EQ              reduce using rule 29 (expr -> lvalue .)
    NEQ             reduce using rule 29 (expr -> lvalue .)
    GTEQ            reduce using rule 29 (expr -> lvalue .)
    LTEQ            reduce using rule 29 (expr -> lvalue .)
    >               reduce using rule 29 (expr -> lvalue .)
    <               reduce using rule 29 (expr -> lvalue .)
    ,               reduce using rule 29 (expr -> lvalue .)
    )               reduce using rule 29 (expr -> lvalue .)
    ]               reduce using rule 29 (expr -> lvalue .)
    :               reduce using rule 29 (expr -> lvalue .)
    {               reduce using rule 29 (expr -> lvalue .)
    BREAK           reduce using rule 29 (expr -> lvalue .)
    CONTINUE        reduce using rule 29 (expr -> lvalue .)
    RETURN          reduce using rule 29 (expr -> lvalue .)
    PRINT           reduce using rule 29 (expr -> lvalue .)
    IF              reduce using rule 29 (expr -> lvalue .)
    WHILE           reduce using rule 29 (expr -> lvalue .)
    FOR             reduce using rule 29 (expr -> lvalue .)
    ID              reduce using rule 29 (expr -> lvalue .)
    =               shift and go to state 37
    PLUSASSIGN      shift and go to state 38
    MINASSIGN       shift and go to state 39
    MULTASSIGN      shift and go to state 40
    DIVASSIGN       shift and go to state 41


state 31

    (31) expr -> - . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 70
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 32

    (35) expr -> [ . array_interior ]
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    array_interior                 shift and go to state 71
    expr                           shift and go to state 36
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 33

    (43) expr -> assignment .

    ;               reduce using rule 43 (expr -> assignment .)
    '               reduce using rule 43 (expr -> assignment .)
    +               reduce using rule 43 (expr -> assignment .)
    -               reduce using rule 43 (expr -> assignment .)
    *               reduce using rule 43 (expr -> assignment .)
    /               reduce using rule 43 (expr -> assignment .)
    MPLUS           reduce using rule 43 (expr -> assignment .)
    MMINUS          reduce using rule 43 (expr -> assignment .)
    MMLTP           reduce using rule 43 (expr -> assignment .)
    MDIV            reduce using rule 43 (expr -> assignment .)
    EQ              reduce using rule 43 (expr -> assignment .)
    NEQ             reduce using rule 43 (expr -> assignment .)
    GTEQ            reduce using rule 43 (expr -> assignment .)
    LTEQ            reduce using rule 43 (expr -> assignment .)
    >               reduce using rule 43 (expr -> assignment .)
    <               reduce using rule 43 (expr -> assignment .)
    ,               reduce using rule 43 (expr -> assignment .)
    )               reduce using rule 43 (expr -> assignment .)
    ]               reduce using rule 43 (expr -> assignment .)
    :               reduce using rule 43 (expr -> assignment .)
    {               reduce using rule 43 (expr -> assignment .)
    BREAK           reduce using rule 43 (expr -> assignment .)
    CONTINUE        reduce using rule 43 (expr -> assignment .)
    RETURN          reduce using rule 43 (expr -> assignment .)
    PRINT           reduce using rule 43 (expr -> assignment .)
    IF              reduce using rule 43 (expr -> assignment .)
    WHILE           reduce using rule 43 (expr -> assignment .)
    FOR             reduce using rule 43 (expr -> assignment .)
    ID              reduce using rule 43 (expr -> assignment .)


state 34

    (72) instruction -> RETURN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 72 (instruction -> RETURN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 35

    (73) instruction -> PRINT array_interior .
    (33) array_interior -> array_interior . , expr

    ;               reduce using rule 73 (instruction -> PRINT array_interior .)
    ,               shift and go to state 72


state 36

    (34) array_interior -> expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ,               reduce using rule 34 (array_interior -> expr .)
    ;               reduce using rule 34 (array_interior -> expr .)
    ]               reduce using rule 34 (array_interior -> expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 37

    (38) assignment -> lvalue = . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    lvalue                         shift and go to state 30
    expr                           shift and go to state 73
    assignment                     shift and go to state 33

state 38

    (39) assignment -> lvalue PLUSASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    lvalue                         shift and go to state 30
    expr                           shift and go to state 74
    assignment                     shift and go to state 33

state 39

    (40) assignment -> lvalue MINASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    lvalue                         shift and go to state 30
    expr                           shift and go to state 75
    assignment                     shift and go to state 33

state 40

    (41) assignment -> lvalue MULTASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    lvalue                         shift and go to state 30
    expr                           shift and go to state 76
    assignment                     shift and go to state 33

state 41

    (42) assignment -> lvalue DIVASSIGN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    lvalue                         shift and go to state 30
    expr                           shift and go to state 77
    assignment                     shift and go to state 33

state 42

    (62) cond_if -> IF ( . expr ) cond_block
    (63) cond_if -> IF ( . expr ) cond_block ELSE cond_block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 78
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 43

    (70) cond_while -> WHILE ( . expr ) loop_cond_block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 79
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 44

    (71) cond_for -> FOR ID . = expr : expr loop_cond_block

    =               shift and go to state 80


state 45

    (37) lvalue -> ID [ . array_interior ]
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    array_interior                 shift and go to state 81
    expr                           shift and go to state 36
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 46

    (5) struct -> { block_interior } .

    {               reduce using rule 5 (struct -> { block_interior } .)
    RETURN          reduce using rule 5 (struct -> { block_interior } .)
    PRINT           reduce using rule 5 (struct -> { block_interior } .)
    IF              reduce using rule 5 (struct -> { block_interior } .)
    WHILE           reduce using rule 5 (struct -> { block_interior } .)
    FOR             reduce using rule 5 (struct -> { block_interior } .)
    ID              reduce using rule 5 (struct -> { block_interior } .)
    $end            reduce using rule 5 (struct -> { block_interior } .)
    ELSE            reduce using rule 5 (struct -> { block_interior } .)


state 47

    (6) block_interior -> block_interior expr . ;
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               shift and go to state 82
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 48

    (7) block_interior -> block_interior instruction . ;

    ;               shift and go to state 83


state 49

    (8) block_interior -> expr ; .

    }               reduce using rule 8 (block_interior -> expr ; .)
    INTNUM          reduce using rule 8 (block_interior -> expr ; .)
    FLOATNUM        reduce using rule 8 (block_interior -> expr ; .)
    STRING          reduce using rule 8 (block_interior -> expr ; .)
    ZEROS           reduce using rule 8 (block_interior -> expr ; .)
    ONES            reduce using rule 8 (block_interior -> expr ; .)
    EYE             reduce using rule 8 (block_interior -> expr ; .)
    (               reduce using rule 8 (block_interior -> expr ; .)
    -               reduce using rule 8 (block_interior -> expr ; .)
    [               reduce using rule 8 (block_interior -> expr ; .)
    RETURN          reduce using rule 8 (block_interior -> expr ; .)
    PRINT           reduce using rule 8 (block_interior -> expr ; .)
    ID              reduce using rule 8 (block_interior -> expr ; .)


state 50

    (32) expr -> expr ' .

    ;               reduce using rule 32 (expr -> expr ' .)
    '               reduce using rule 32 (expr -> expr ' .)
    +               reduce using rule 32 (expr -> expr ' .)
    -               reduce using rule 32 (expr -> expr ' .)
    *               reduce using rule 32 (expr -> expr ' .)
    /               reduce using rule 32 (expr -> expr ' .)
    MPLUS           reduce using rule 32 (expr -> expr ' .)
    MMINUS          reduce using rule 32 (expr -> expr ' .)
    MMLTP           reduce using rule 32 (expr -> expr ' .)
    MDIV            reduce using rule 32 (expr -> expr ' .)
    EQ              reduce using rule 32 (expr -> expr ' .)
    NEQ             reduce using rule 32 (expr -> expr ' .)
    GTEQ            reduce using rule 32 (expr -> expr ' .)
    LTEQ            reduce using rule 32 (expr -> expr ' .)
    >               reduce using rule 32 (expr -> expr ' .)
    <               reduce using rule 32 (expr -> expr ' .)
    ,               reduce using rule 32 (expr -> expr ' .)
    )               reduce using rule 32 (expr -> expr ' .)
    ]               reduce using rule 32 (expr -> expr ' .)
    :               reduce using rule 32 (expr -> expr ' .)
    {               reduce using rule 32 (expr -> expr ' .)
    BREAK           reduce using rule 32 (expr -> expr ' .)
    CONTINUE        reduce using rule 32 (expr -> expr ' .)
    RETURN          reduce using rule 32 (expr -> expr ' .)
    PRINT           reduce using rule 32 (expr -> expr ' .)
    IF              reduce using rule 32 (expr -> expr ' .)
    WHILE           reduce using rule 32 (expr -> expr ' .)
    FOR             reduce using rule 32 (expr -> expr ' .)
    ID              reduce using rule 32 (expr -> expr ' .)


state 51

    (44) expr -> expr + . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 84
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 52

    (45) expr -> expr - . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 85
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 53

    (46) expr -> expr * . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 86
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 54

    (47) expr -> expr / . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 87
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 55

    (48) expr -> expr MPLUS . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 88
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 56

    (49) expr -> expr MMINUS . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 89
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 57

    (50) expr -> expr MMLTP . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 90
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 58

    (51) expr -> expr MDIV . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 91
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 59

    (52) expr -> expr EQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 92
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 60

    (53) expr -> expr NEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 93
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 61

    (54) expr -> expr GTEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 94
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 62

    (55) expr -> expr LTEQ . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 95
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 63

    (56) expr -> expr > . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 96
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 64

    (57) expr -> expr < . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 97
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 65

    (9) block_interior -> instruction ; .

    }               reduce using rule 9 (block_interior -> instruction ; .)
    INTNUM          reduce using rule 9 (block_interior -> instruction ; .)
    FLOATNUM        reduce using rule 9 (block_interior -> instruction ; .)
    STRING          reduce using rule 9 (block_interior -> instruction ; .)
    ZEROS           reduce using rule 9 (block_interior -> instruction ; .)
    ONES            reduce using rule 9 (block_interior -> instruction ; .)
    EYE             reduce using rule 9 (block_interior -> instruction ; .)
    (               reduce using rule 9 (block_interior -> instruction ; .)
    -               reduce using rule 9 (block_interior -> instruction ; .)
    [               reduce using rule 9 (block_interior -> instruction ; .)
    RETURN          reduce using rule 9 (block_interior -> instruction ; .)
    PRINT           reduce using rule 9 (block_interior -> instruction ; .)
    ID              reduce using rule 9 (block_interior -> instruction ; .)


state 66

    (26) expr -> ZEROS ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 98
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 67

    (30) expr -> ( expr . )
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 99
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 68

    (27) expr -> ONES ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 100
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 69

    (28) expr -> EYE ( . expr )
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 101
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 70

    (31) expr -> - expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 31 (expr -> - expr .)
    +               reduce using rule 31 (expr -> - expr .)
    -               reduce using rule 31 (expr -> - expr .)
    *               reduce using rule 31 (expr -> - expr .)
    /               reduce using rule 31 (expr -> - expr .)
    MPLUS           reduce using rule 31 (expr -> - expr .)
    MMINUS          reduce using rule 31 (expr -> - expr .)
    MMLTP           reduce using rule 31 (expr -> - expr .)
    MDIV            reduce using rule 31 (expr -> - expr .)
    EQ              reduce using rule 31 (expr -> - expr .)
    NEQ             reduce using rule 31 (expr -> - expr .)
    GTEQ            reduce using rule 31 (expr -> - expr .)
    LTEQ            reduce using rule 31 (expr -> - expr .)
    >               reduce using rule 31 (expr -> - expr .)
    <               reduce using rule 31 (expr -> - expr .)
    ,               reduce using rule 31 (expr -> - expr .)
    )               reduce using rule 31 (expr -> - expr .)
    ]               reduce using rule 31 (expr -> - expr .)
    :               reduce using rule 31 (expr -> - expr .)
    {               reduce using rule 31 (expr -> - expr .)
    BREAK           reduce using rule 31 (expr -> - expr .)
    CONTINUE        reduce using rule 31 (expr -> - expr .)
    RETURN          reduce using rule 31 (expr -> - expr .)
    PRINT           reduce using rule 31 (expr -> - expr .)
    IF              reduce using rule 31 (expr -> - expr .)
    WHILE           reduce using rule 31 (expr -> - expr .)
    FOR             reduce using rule 31 (expr -> - expr .)
    ID              reduce using rule 31 (expr -> - expr .)
    '               shift and go to state 50

  ! '               [ reduce using rule 31 (expr -> - expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! MMLTP           [ shift and go to state 57 ]
  ! MDIV            [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 71

    (35) expr -> [ array_interior . ]
    (33) array_interior -> array_interior . , expr

    ]               shift and go to state 102
    ,               shift and go to state 72


state 72

    (33) array_interior -> array_interior , . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 103
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 73

    (38) assignment -> lvalue = expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 38 (assignment -> lvalue = expr .)
    ,               reduce using rule 38 (assignment -> lvalue = expr .)
    )               reduce using rule 38 (assignment -> lvalue = expr .)
    ]               reduce using rule 38 (assignment -> lvalue = expr .)
    :               reduce using rule 38 (assignment -> lvalue = expr .)
    {               reduce using rule 38 (assignment -> lvalue = expr .)
    BREAK           reduce using rule 38 (assignment -> lvalue = expr .)
    CONTINUE        reduce using rule 38 (assignment -> lvalue = expr .)
    RETURN          reduce using rule 38 (assignment -> lvalue = expr .)
    PRINT           reduce using rule 38 (assignment -> lvalue = expr .)
    IF              reduce using rule 38 (assignment -> lvalue = expr .)
    WHILE           reduce using rule 38 (assignment -> lvalue = expr .)
    FOR             reduce using rule 38 (assignment -> lvalue = expr .)
    ID              reduce using rule 38 (assignment -> lvalue = expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64

  ! '               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! +               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! -               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! *               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! /               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! MPLUS           [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! MMINUS          [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! MMLTP           [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! MDIV            [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! EQ              [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! NEQ             [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! GTEQ            [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! LTEQ            [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! >               [ reduce using rule 38 (assignment -> lvalue = expr .) ]
  ! <               [ reduce using rule 38 (assignment -> lvalue = expr .) ]


state 74

    (39) assignment -> lvalue PLUSASSIGN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    ,               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    )               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    ]               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    :               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    {               reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    BREAK           reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    CONTINUE        reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    RETURN          reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    PRINT           reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    IF              reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    WHILE           reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    FOR             reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    ID              reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64

  ! '               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! +               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! -               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! *               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! /               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! MDIV            [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! EQ              [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! NEQ             [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! >               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]
  ! <               [ reduce using rule 39 (assignment -> lvalue PLUSASSIGN expr .) ]


state 75

    (40) assignment -> lvalue MINASSIGN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    ,               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    )               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    ]               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    :               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    {               reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    BREAK           reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    CONTINUE        reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    RETURN          reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    PRINT           reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    IF              reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    WHILE           reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    FOR             reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    ID              reduce using rule 40 (assignment -> lvalue MINASSIGN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64

  ! '               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! +               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! -               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! *               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! /               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! MDIV            [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! EQ              [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! NEQ             [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! >               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]
  ! <               [ reduce using rule 40 (assignment -> lvalue MINASSIGN expr .) ]


state 76

    (41) assignment -> lvalue MULTASSIGN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    ,               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    )               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    ]               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    :               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    {               reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    BREAK           reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    CONTINUE        reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    RETURN          reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    PRINT           reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    IF              reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    WHILE           reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    FOR             reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    ID              reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64

  ! '               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! +               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! -               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! *               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! /               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! MDIV            [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! EQ              [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! NEQ             [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! >               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]
  ! <               [ reduce using rule 41 (assignment -> lvalue MULTASSIGN expr .) ]


state 77

    (42) assignment -> lvalue DIVASSIGN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    ,               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    )               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    ]               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    :               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    {               reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    BREAK           reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    CONTINUE        reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    RETURN          reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    PRINT           reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    IF              reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    WHILE           reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    FOR             reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    ID              reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64

  ! '               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! +               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! -               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! *               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! /               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MPLUS           [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MMINUS          [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MMLTP           [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! MDIV            [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! EQ              [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! NEQ             [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! GTEQ            [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! LTEQ            [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! >               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]
  ! <               [ reduce using rule 42 (assignment -> lvalue DIVASSIGN expr .) ]


state 78

    (62) cond_if -> IF ( expr . ) cond_block
    (63) cond_if -> IF ( expr . ) cond_block ELSE cond_block
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 104
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 79

    (70) cond_while -> WHILE ( expr . ) loop_cond_block
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 105
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 80

    (71) cond_for -> FOR ID = . expr : expr loop_cond_block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 106
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 81

    (37) lvalue -> ID [ array_interior . ]
    (33) array_interior -> array_interior . , expr

    ]               shift and go to state 107
    ,               shift and go to state 72


state 82

    (6) block_interior -> block_interior expr ; .

    }               reduce using rule 6 (block_interior -> block_interior expr ; .)
    INTNUM          reduce using rule 6 (block_interior -> block_interior expr ; .)
    FLOATNUM        reduce using rule 6 (block_interior -> block_interior expr ; .)
    STRING          reduce using rule 6 (block_interior -> block_interior expr ; .)
    ZEROS           reduce using rule 6 (block_interior -> block_interior expr ; .)
    ONES            reduce using rule 6 (block_interior -> block_interior expr ; .)
    EYE             reduce using rule 6 (block_interior -> block_interior expr ; .)
    (               reduce using rule 6 (block_interior -> block_interior expr ; .)
    -               reduce using rule 6 (block_interior -> block_interior expr ; .)
    [               reduce using rule 6 (block_interior -> block_interior expr ; .)
    RETURN          reduce using rule 6 (block_interior -> block_interior expr ; .)
    PRINT           reduce using rule 6 (block_interior -> block_interior expr ; .)
    ID              reduce using rule 6 (block_interior -> block_interior expr ; .)


state 83

    (7) block_interior -> block_interior instruction ; .

    }               reduce using rule 7 (block_interior -> block_interior instruction ; .)
    INTNUM          reduce using rule 7 (block_interior -> block_interior instruction ; .)
    FLOATNUM        reduce using rule 7 (block_interior -> block_interior instruction ; .)
    STRING          reduce using rule 7 (block_interior -> block_interior instruction ; .)
    ZEROS           reduce using rule 7 (block_interior -> block_interior instruction ; .)
    ONES            reduce using rule 7 (block_interior -> block_interior instruction ; .)
    EYE             reduce using rule 7 (block_interior -> block_interior instruction ; .)
    (               reduce using rule 7 (block_interior -> block_interior instruction ; .)
    -               reduce using rule 7 (block_interior -> block_interior instruction ; .)
    [               reduce using rule 7 (block_interior -> block_interior instruction ; .)
    RETURN          reduce using rule 7 (block_interior -> block_interior instruction ; .)
    PRINT           reduce using rule 7 (block_interior -> block_interior instruction ; .)
    ID              reduce using rule 7 (block_interior -> block_interior instruction ; .)


state 84

    (44) expr -> expr + expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 44 (expr -> expr + expr .)
    +               reduce using rule 44 (expr -> expr + expr .)
    -               reduce using rule 44 (expr -> expr + expr .)
    MPLUS           reduce using rule 44 (expr -> expr + expr .)
    MMINUS          reduce using rule 44 (expr -> expr + expr .)
    EQ              reduce using rule 44 (expr -> expr + expr .)
    NEQ             reduce using rule 44 (expr -> expr + expr .)
    GTEQ            reduce using rule 44 (expr -> expr + expr .)
    LTEQ            reduce using rule 44 (expr -> expr + expr .)
    >               reduce using rule 44 (expr -> expr + expr .)
    <               reduce using rule 44 (expr -> expr + expr .)
    ,               reduce using rule 44 (expr -> expr + expr .)
    )               reduce using rule 44 (expr -> expr + expr .)
    ]               reduce using rule 44 (expr -> expr + expr .)
    :               reduce using rule 44 (expr -> expr + expr .)
    {               reduce using rule 44 (expr -> expr + expr .)
    BREAK           reduce using rule 44 (expr -> expr + expr .)
    CONTINUE        reduce using rule 44 (expr -> expr + expr .)
    RETURN          reduce using rule 44 (expr -> expr + expr .)
    PRINT           reduce using rule 44 (expr -> expr + expr .)
    IF              reduce using rule 44 (expr -> expr + expr .)
    WHILE           reduce using rule 44 (expr -> expr + expr .)
    FOR             reduce using rule 44 (expr -> expr + expr .)
    ID              reduce using rule 44 (expr -> expr + expr .)
    '               shift and go to state 50
    *               shift and go to state 53
    /               shift and go to state 54
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! *               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! MMLTP           [ reduce using rule 44 (expr -> expr + expr .) ]
  ! MDIV            [ reduce using rule 44 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 85

    (45) expr -> expr - expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 45 (expr -> expr - expr .)
    +               reduce using rule 45 (expr -> expr - expr .)
    -               reduce using rule 45 (expr -> expr - expr .)
    MPLUS           reduce using rule 45 (expr -> expr - expr .)
    MMINUS          reduce using rule 45 (expr -> expr - expr .)
    EQ              reduce using rule 45 (expr -> expr - expr .)
    NEQ             reduce using rule 45 (expr -> expr - expr .)
    GTEQ            reduce using rule 45 (expr -> expr - expr .)
    LTEQ            reduce using rule 45 (expr -> expr - expr .)
    >               reduce using rule 45 (expr -> expr - expr .)
    <               reduce using rule 45 (expr -> expr - expr .)
    ,               reduce using rule 45 (expr -> expr - expr .)
    )               reduce using rule 45 (expr -> expr - expr .)
    ]               reduce using rule 45 (expr -> expr - expr .)
    :               reduce using rule 45 (expr -> expr - expr .)
    {               reduce using rule 45 (expr -> expr - expr .)
    BREAK           reduce using rule 45 (expr -> expr - expr .)
    CONTINUE        reduce using rule 45 (expr -> expr - expr .)
    RETURN          reduce using rule 45 (expr -> expr - expr .)
    PRINT           reduce using rule 45 (expr -> expr - expr .)
    IF              reduce using rule 45 (expr -> expr - expr .)
    WHILE           reduce using rule 45 (expr -> expr - expr .)
    FOR             reduce using rule 45 (expr -> expr - expr .)
    ID              reduce using rule 45 (expr -> expr - expr .)
    '               shift and go to state 50
    *               shift and go to state 53
    /               shift and go to state 54
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! MMLTP           [ reduce using rule 45 (expr -> expr - expr .) ]
  ! MDIV            [ reduce using rule 45 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 86

    (46) expr -> expr * expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 46 (expr -> expr * expr .)
    +               reduce using rule 46 (expr -> expr * expr .)
    -               reduce using rule 46 (expr -> expr * expr .)
    *               reduce using rule 46 (expr -> expr * expr .)
    /               reduce using rule 46 (expr -> expr * expr .)
    MPLUS           reduce using rule 46 (expr -> expr * expr .)
    MMINUS          reduce using rule 46 (expr -> expr * expr .)
    MMLTP           reduce using rule 46 (expr -> expr * expr .)
    MDIV            reduce using rule 46 (expr -> expr * expr .)
    EQ              reduce using rule 46 (expr -> expr * expr .)
    NEQ             reduce using rule 46 (expr -> expr * expr .)
    GTEQ            reduce using rule 46 (expr -> expr * expr .)
    LTEQ            reduce using rule 46 (expr -> expr * expr .)
    >               reduce using rule 46 (expr -> expr * expr .)
    <               reduce using rule 46 (expr -> expr * expr .)
    ,               reduce using rule 46 (expr -> expr * expr .)
    )               reduce using rule 46 (expr -> expr * expr .)
    ]               reduce using rule 46 (expr -> expr * expr .)
    :               reduce using rule 46 (expr -> expr * expr .)
    {               reduce using rule 46 (expr -> expr * expr .)
    BREAK           reduce using rule 46 (expr -> expr * expr .)
    CONTINUE        reduce using rule 46 (expr -> expr * expr .)
    RETURN          reduce using rule 46 (expr -> expr * expr .)
    PRINT           reduce using rule 46 (expr -> expr * expr .)
    IF              reduce using rule 46 (expr -> expr * expr .)
    WHILE           reduce using rule 46 (expr -> expr * expr .)
    FOR             reduce using rule 46 (expr -> expr * expr .)
    ID              reduce using rule 46 (expr -> expr * expr .)
    '               shift and go to state 50

  ! '               [ reduce using rule 46 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! MMLTP           [ shift and go to state 57 ]
  ! MDIV            [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 87

    (47) expr -> expr / expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 47 (expr -> expr / expr .)
    +               reduce using rule 47 (expr -> expr / expr .)
    -               reduce using rule 47 (expr -> expr / expr .)
    *               reduce using rule 47 (expr -> expr / expr .)
    /               reduce using rule 47 (expr -> expr / expr .)
    MPLUS           reduce using rule 47 (expr -> expr / expr .)
    MMINUS          reduce using rule 47 (expr -> expr / expr .)
    MMLTP           reduce using rule 47 (expr -> expr / expr .)
    MDIV            reduce using rule 47 (expr -> expr / expr .)
    EQ              reduce using rule 47 (expr -> expr / expr .)
    NEQ             reduce using rule 47 (expr -> expr / expr .)
    GTEQ            reduce using rule 47 (expr -> expr / expr .)
    LTEQ            reduce using rule 47 (expr -> expr / expr .)
    >               reduce using rule 47 (expr -> expr / expr .)
    <               reduce using rule 47 (expr -> expr / expr .)
    ,               reduce using rule 47 (expr -> expr / expr .)
    )               reduce using rule 47 (expr -> expr / expr .)
    ]               reduce using rule 47 (expr -> expr / expr .)
    :               reduce using rule 47 (expr -> expr / expr .)
    {               reduce using rule 47 (expr -> expr / expr .)
    BREAK           reduce using rule 47 (expr -> expr / expr .)
    CONTINUE        reduce using rule 47 (expr -> expr / expr .)
    RETURN          reduce using rule 47 (expr -> expr / expr .)
    PRINT           reduce using rule 47 (expr -> expr / expr .)
    IF              reduce using rule 47 (expr -> expr / expr .)
    WHILE           reduce using rule 47 (expr -> expr / expr .)
    FOR             reduce using rule 47 (expr -> expr / expr .)
    ID              reduce using rule 47 (expr -> expr / expr .)
    '               shift and go to state 50

  ! '               [ reduce using rule 47 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! MMLTP           [ shift and go to state 57 ]
  ! MDIV            [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 88

    (48) expr -> expr MPLUS expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 48 (expr -> expr MPLUS expr .)
    +               reduce using rule 48 (expr -> expr MPLUS expr .)
    -               reduce using rule 48 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 48 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 48 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 48 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 48 (expr -> expr MPLUS expr .)
    GTEQ            reduce using rule 48 (expr -> expr MPLUS expr .)
    LTEQ            reduce using rule 48 (expr -> expr MPLUS expr .)
    >               reduce using rule 48 (expr -> expr MPLUS expr .)
    <               reduce using rule 48 (expr -> expr MPLUS expr .)
    ,               reduce using rule 48 (expr -> expr MPLUS expr .)
    )               reduce using rule 48 (expr -> expr MPLUS expr .)
    ]               reduce using rule 48 (expr -> expr MPLUS expr .)
    :               reduce using rule 48 (expr -> expr MPLUS expr .)
    {               reduce using rule 48 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 48 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 48 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 48 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 48 (expr -> expr MPLUS expr .)
    IF              reduce using rule 48 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 48 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 48 (expr -> expr MPLUS expr .)
    ID              reduce using rule 48 (expr -> expr MPLUS expr .)
    '               shift and go to state 50
    *               shift and go to state 53
    /               shift and go to state 54
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 48 (expr -> expr MPLUS expr .) ]
  ! *               [ reduce using rule 48 (expr -> expr MPLUS expr .) ]
  ! /               [ reduce using rule 48 (expr -> expr MPLUS expr .) ]
  ! MMLTP           [ reduce using rule 48 (expr -> expr MPLUS expr .) ]
  ! MDIV            [ reduce using rule 48 (expr -> expr MPLUS expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 89

    (49) expr -> expr MMINUS expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 49 (expr -> expr MMINUS expr .)
    +               reduce using rule 49 (expr -> expr MMINUS expr .)
    -               reduce using rule 49 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 49 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 49 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 49 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 49 (expr -> expr MMINUS expr .)
    GTEQ            reduce using rule 49 (expr -> expr MMINUS expr .)
    LTEQ            reduce using rule 49 (expr -> expr MMINUS expr .)
    >               reduce using rule 49 (expr -> expr MMINUS expr .)
    <               reduce using rule 49 (expr -> expr MMINUS expr .)
    ,               reduce using rule 49 (expr -> expr MMINUS expr .)
    )               reduce using rule 49 (expr -> expr MMINUS expr .)
    ]               reduce using rule 49 (expr -> expr MMINUS expr .)
    :               reduce using rule 49 (expr -> expr MMINUS expr .)
    {               reduce using rule 49 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 49 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 49 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 49 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 49 (expr -> expr MMINUS expr .)
    IF              reduce using rule 49 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 49 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 49 (expr -> expr MMINUS expr .)
    ID              reduce using rule 49 (expr -> expr MMINUS expr .)
    '               shift and go to state 50
    *               shift and go to state 53
    /               shift and go to state 54
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 49 (expr -> expr MMINUS expr .) ]
  ! *               [ reduce using rule 49 (expr -> expr MMINUS expr .) ]
  ! /               [ reduce using rule 49 (expr -> expr MMINUS expr .) ]
  ! MMLTP           [ reduce using rule 49 (expr -> expr MMINUS expr .) ]
  ! MDIV            [ reduce using rule 49 (expr -> expr MMINUS expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 90

    (50) expr -> expr MMLTP expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 50 (expr -> expr MMLTP expr .)
    +               reduce using rule 50 (expr -> expr MMLTP expr .)
    -               reduce using rule 50 (expr -> expr MMLTP expr .)
    *               reduce using rule 50 (expr -> expr MMLTP expr .)
    /               reduce using rule 50 (expr -> expr MMLTP expr .)
    MPLUS           reduce using rule 50 (expr -> expr MMLTP expr .)
    MMINUS          reduce using rule 50 (expr -> expr MMLTP expr .)
    MMLTP           reduce using rule 50 (expr -> expr MMLTP expr .)
    MDIV            reduce using rule 50 (expr -> expr MMLTP expr .)
    EQ              reduce using rule 50 (expr -> expr MMLTP expr .)
    NEQ             reduce using rule 50 (expr -> expr MMLTP expr .)
    GTEQ            reduce using rule 50 (expr -> expr MMLTP expr .)
    LTEQ            reduce using rule 50 (expr -> expr MMLTP expr .)
    >               reduce using rule 50 (expr -> expr MMLTP expr .)
    <               reduce using rule 50 (expr -> expr MMLTP expr .)
    ,               reduce using rule 50 (expr -> expr MMLTP expr .)
    )               reduce using rule 50 (expr -> expr MMLTP expr .)
    ]               reduce using rule 50 (expr -> expr MMLTP expr .)
    :               reduce using rule 50 (expr -> expr MMLTP expr .)
    {               reduce using rule 50 (expr -> expr MMLTP expr .)
    BREAK           reduce using rule 50 (expr -> expr MMLTP expr .)
    CONTINUE        reduce using rule 50 (expr -> expr MMLTP expr .)
    RETURN          reduce using rule 50 (expr -> expr MMLTP expr .)
    PRINT           reduce using rule 50 (expr -> expr MMLTP expr .)
    IF              reduce using rule 50 (expr -> expr MMLTP expr .)
    WHILE           reduce using rule 50 (expr -> expr MMLTP expr .)
    FOR             reduce using rule 50 (expr -> expr MMLTP expr .)
    ID              reduce using rule 50 (expr -> expr MMLTP expr .)
    '               shift and go to state 50

  ! '               [ reduce using rule 50 (expr -> expr MMLTP expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! MMLTP           [ shift and go to state 57 ]
  ! MDIV            [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 91

    (51) expr -> expr MDIV expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 51 (expr -> expr MDIV expr .)
    +               reduce using rule 51 (expr -> expr MDIV expr .)
    -               reduce using rule 51 (expr -> expr MDIV expr .)
    *               reduce using rule 51 (expr -> expr MDIV expr .)
    /               reduce using rule 51 (expr -> expr MDIV expr .)
    MPLUS           reduce using rule 51 (expr -> expr MDIV expr .)
    MMINUS          reduce using rule 51 (expr -> expr MDIV expr .)
    MMLTP           reduce using rule 51 (expr -> expr MDIV expr .)
    MDIV            reduce using rule 51 (expr -> expr MDIV expr .)
    EQ              reduce using rule 51 (expr -> expr MDIV expr .)
    NEQ             reduce using rule 51 (expr -> expr MDIV expr .)
    GTEQ            reduce using rule 51 (expr -> expr MDIV expr .)
    LTEQ            reduce using rule 51 (expr -> expr MDIV expr .)
    >               reduce using rule 51 (expr -> expr MDIV expr .)
    <               reduce using rule 51 (expr -> expr MDIV expr .)
    ,               reduce using rule 51 (expr -> expr MDIV expr .)
    )               reduce using rule 51 (expr -> expr MDIV expr .)
    ]               reduce using rule 51 (expr -> expr MDIV expr .)
    :               reduce using rule 51 (expr -> expr MDIV expr .)
    {               reduce using rule 51 (expr -> expr MDIV expr .)
    BREAK           reduce using rule 51 (expr -> expr MDIV expr .)
    CONTINUE        reduce using rule 51 (expr -> expr MDIV expr .)
    RETURN          reduce using rule 51 (expr -> expr MDIV expr .)
    PRINT           reduce using rule 51 (expr -> expr MDIV expr .)
    IF              reduce using rule 51 (expr -> expr MDIV expr .)
    WHILE           reduce using rule 51 (expr -> expr MDIV expr .)
    FOR             reduce using rule 51 (expr -> expr MDIV expr .)
    ID              reduce using rule 51 (expr -> expr MDIV expr .)
    '               shift and go to state 50

  ! '               [ reduce using rule 51 (expr -> expr MDIV expr .) ]
  ! +               [ shift and go to state 51 ]
  ! -               [ shift and go to state 52 ]
  ! *               [ shift and go to state 53 ]
  ! /               [ shift and go to state 54 ]
  ! MPLUS           [ shift and go to state 55 ]
  ! MMINUS          [ shift and go to state 56 ]
  ! MMLTP           [ shift and go to state 57 ]
  ! MDIV            [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 92

    (52) expr -> expr EQ expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 52 (expr -> expr EQ expr .)
    EQ              reduce using rule 52 (expr -> expr EQ expr .)
    NEQ             reduce using rule 52 (expr -> expr EQ expr .)
    GTEQ            reduce using rule 52 (expr -> expr EQ expr .)
    LTEQ            reduce using rule 52 (expr -> expr EQ expr .)
    >               reduce using rule 52 (expr -> expr EQ expr .)
    <               reduce using rule 52 (expr -> expr EQ expr .)
    ,               reduce using rule 52 (expr -> expr EQ expr .)
    )               reduce using rule 52 (expr -> expr EQ expr .)
    ]               reduce using rule 52 (expr -> expr EQ expr .)
    :               reduce using rule 52 (expr -> expr EQ expr .)
    {               reduce using rule 52 (expr -> expr EQ expr .)
    BREAK           reduce using rule 52 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 52 (expr -> expr EQ expr .)
    RETURN          reduce using rule 52 (expr -> expr EQ expr .)
    PRINT           reduce using rule 52 (expr -> expr EQ expr .)
    IF              reduce using rule 52 (expr -> expr EQ expr .)
    WHILE           reduce using rule 52 (expr -> expr EQ expr .)
    FOR             reduce using rule 52 (expr -> expr EQ expr .)
    ID              reduce using rule 52 (expr -> expr EQ expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! MPLUS           [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! MMINUS          [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! MMLTP           [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! MDIV            [ reduce using rule 52 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 93

    (53) expr -> expr NEQ expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 53 (expr -> expr NEQ expr .)
    EQ              reduce using rule 53 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 53 (expr -> expr NEQ expr .)
    GTEQ            reduce using rule 53 (expr -> expr NEQ expr .)
    LTEQ            reduce using rule 53 (expr -> expr NEQ expr .)
    >               reduce using rule 53 (expr -> expr NEQ expr .)
    <               reduce using rule 53 (expr -> expr NEQ expr .)
    ,               reduce using rule 53 (expr -> expr NEQ expr .)
    )               reduce using rule 53 (expr -> expr NEQ expr .)
    ]               reduce using rule 53 (expr -> expr NEQ expr .)
    :               reduce using rule 53 (expr -> expr NEQ expr .)
    {               reduce using rule 53 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 53 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 53 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 53 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 53 (expr -> expr NEQ expr .)
    IF              reduce using rule 53 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 53 (expr -> expr NEQ expr .)
    FOR             reduce using rule 53 (expr -> expr NEQ expr .)
    ID              reduce using rule 53 (expr -> expr NEQ expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! +               [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! MPLUS           [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! MMINUS          [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! MMLTP           [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! MDIV            [ reduce using rule 53 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 94

    (54) expr -> expr GTEQ expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 54 (expr -> expr GTEQ expr .)
    EQ              reduce using rule 54 (expr -> expr GTEQ expr .)
    NEQ             reduce using rule 54 (expr -> expr GTEQ expr .)
    GTEQ            reduce using rule 54 (expr -> expr GTEQ expr .)
    LTEQ            reduce using rule 54 (expr -> expr GTEQ expr .)
    >               reduce using rule 54 (expr -> expr GTEQ expr .)
    <               reduce using rule 54 (expr -> expr GTEQ expr .)
    ,               reduce using rule 54 (expr -> expr GTEQ expr .)
    )               reduce using rule 54 (expr -> expr GTEQ expr .)
    ]               reduce using rule 54 (expr -> expr GTEQ expr .)
    :               reduce using rule 54 (expr -> expr GTEQ expr .)
    {               reduce using rule 54 (expr -> expr GTEQ expr .)
    BREAK           reduce using rule 54 (expr -> expr GTEQ expr .)
    CONTINUE        reduce using rule 54 (expr -> expr GTEQ expr .)
    RETURN          reduce using rule 54 (expr -> expr GTEQ expr .)
    PRINT           reduce using rule 54 (expr -> expr GTEQ expr .)
    IF              reduce using rule 54 (expr -> expr GTEQ expr .)
    WHILE           reduce using rule 54 (expr -> expr GTEQ expr .)
    FOR             reduce using rule 54 (expr -> expr GTEQ expr .)
    ID              reduce using rule 54 (expr -> expr GTEQ expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! +               [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! -               [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! *               [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! /               [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! MPLUS           [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! MMINUS          [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! MMLTP           [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! MDIV            [ reduce using rule 54 (expr -> expr GTEQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 95

    (55) expr -> expr LTEQ expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 55 (expr -> expr LTEQ expr .)
    EQ              reduce using rule 55 (expr -> expr LTEQ expr .)
    NEQ             reduce using rule 55 (expr -> expr LTEQ expr .)
    GTEQ            reduce using rule 55 (expr -> expr LTEQ expr .)
    LTEQ            reduce using rule 55 (expr -> expr LTEQ expr .)
    >               reduce using rule 55 (expr -> expr LTEQ expr .)
    <               reduce using rule 55 (expr -> expr LTEQ expr .)
    ,               reduce using rule 55 (expr -> expr LTEQ expr .)
    )               reduce using rule 55 (expr -> expr LTEQ expr .)
    ]               reduce using rule 55 (expr -> expr LTEQ expr .)
    :               reduce using rule 55 (expr -> expr LTEQ expr .)
    {               reduce using rule 55 (expr -> expr LTEQ expr .)
    BREAK           reduce using rule 55 (expr -> expr LTEQ expr .)
    CONTINUE        reduce using rule 55 (expr -> expr LTEQ expr .)
    RETURN          reduce using rule 55 (expr -> expr LTEQ expr .)
    PRINT           reduce using rule 55 (expr -> expr LTEQ expr .)
    IF              reduce using rule 55 (expr -> expr LTEQ expr .)
    WHILE           reduce using rule 55 (expr -> expr LTEQ expr .)
    FOR             reduce using rule 55 (expr -> expr LTEQ expr .)
    ID              reduce using rule 55 (expr -> expr LTEQ expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! +               [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! -               [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! *               [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! /               [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! MPLUS           [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! MMINUS          [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! MMLTP           [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! MDIV            [ reduce using rule 55 (expr -> expr LTEQ expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 96

    (56) expr -> expr > expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 56 (expr -> expr > expr .)
    EQ              reduce using rule 56 (expr -> expr > expr .)
    NEQ             reduce using rule 56 (expr -> expr > expr .)
    GTEQ            reduce using rule 56 (expr -> expr > expr .)
    LTEQ            reduce using rule 56 (expr -> expr > expr .)
    >               reduce using rule 56 (expr -> expr > expr .)
    <               reduce using rule 56 (expr -> expr > expr .)
    ,               reduce using rule 56 (expr -> expr > expr .)
    )               reduce using rule 56 (expr -> expr > expr .)
    ]               reduce using rule 56 (expr -> expr > expr .)
    :               reduce using rule 56 (expr -> expr > expr .)
    {               reduce using rule 56 (expr -> expr > expr .)
    BREAK           reduce using rule 56 (expr -> expr > expr .)
    CONTINUE        reduce using rule 56 (expr -> expr > expr .)
    RETURN          reduce using rule 56 (expr -> expr > expr .)
    PRINT           reduce using rule 56 (expr -> expr > expr .)
    IF              reduce using rule 56 (expr -> expr > expr .)
    WHILE           reduce using rule 56 (expr -> expr > expr .)
    FOR             reduce using rule 56 (expr -> expr > expr .)
    ID              reduce using rule 56 (expr -> expr > expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 56 (expr -> expr > expr .) ]
  ! +               [ reduce using rule 56 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 56 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 56 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 56 (expr -> expr > expr .) ]
  ! MPLUS           [ reduce using rule 56 (expr -> expr > expr .) ]
  ! MMINUS          [ reduce using rule 56 (expr -> expr > expr .) ]
  ! MMLTP           [ reduce using rule 56 (expr -> expr > expr .) ]
  ! MDIV            [ reduce using rule 56 (expr -> expr > expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 97

    (57) expr -> expr < expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 57 (expr -> expr < expr .)
    EQ              reduce using rule 57 (expr -> expr < expr .)
    NEQ             reduce using rule 57 (expr -> expr < expr .)
    GTEQ            reduce using rule 57 (expr -> expr < expr .)
    LTEQ            reduce using rule 57 (expr -> expr < expr .)
    >               reduce using rule 57 (expr -> expr < expr .)
    <               reduce using rule 57 (expr -> expr < expr .)
    ,               reduce using rule 57 (expr -> expr < expr .)
    )               reduce using rule 57 (expr -> expr < expr .)
    ]               reduce using rule 57 (expr -> expr < expr .)
    :               reduce using rule 57 (expr -> expr < expr .)
    {               reduce using rule 57 (expr -> expr < expr .)
    BREAK           reduce using rule 57 (expr -> expr < expr .)
    CONTINUE        reduce using rule 57 (expr -> expr < expr .)
    RETURN          reduce using rule 57 (expr -> expr < expr .)
    PRINT           reduce using rule 57 (expr -> expr < expr .)
    IF              reduce using rule 57 (expr -> expr < expr .)
    WHILE           reduce using rule 57 (expr -> expr < expr .)
    FOR             reduce using rule 57 (expr -> expr < expr .)
    ID              reduce using rule 57 (expr -> expr < expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58

  ! '               [ reduce using rule 57 (expr -> expr < expr .) ]
  ! +               [ reduce using rule 57 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 57 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 57 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 57 (expr -> expr < expr .) ]
  ! MPLUS           [ reduce using rule 57 (expr -> expr < expr .) ]
  ! MMINUS          [ reduce using rule 57 (expr -> expr < expr .) ]
  ! MMLTP           [ reduce using rule 57 (expr -> expr < expr .) ]
  ! MDIV            [ reduce using rule 57 (expr -> expr < expr .) ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! GTEQ            [ shift and go to state 61 ]
  ! LTEQ            [ shift and go to state 62 ]
  ! >               [ shift and go to state 63 ]
  ! <               [ shift and go to state 64 ]


state 98

    (26) expr -> ZEROS ( expr . )
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 108
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 99

    (30) expr -> ( expr ) .

    ;               reduce using rule 30 (expr -> ( expr ) .)
    '               reduce using rule 30 (expr -> ( expr ) .)
    +               reduce using rule 30 (expr -> ( expr ) .)
    -               reduce using rule 30 (expr -> ( expr ) .)
    *               reduce using rule 30 (expr -> ( expr ) .)
    /               reduce using rule 30 (expr -> ( expr ) .)
    MPLUS           reduce using rule 30 (expr -> ( expr ) .)
    MMINUS          reduce using rule 30 (expr -> ( expr ) .)
    MMLTP           reduce using rule 30 (expr -> ( expr ) .)
    MDIV            reduce using rule 30 (expr -> ( expr ) .)
    EQ              reduce using rule 30 (expr -> ( expr ) .)
    NEQ             reduce using rule 30 (expr -> ( expr ) .)
    GTEQ            reduce using rule 30 (expr -> ( expr ) .)
    LTEQ            reduce using rule 30 (expr -> ( expr ) .)
    >               reduce using rule 30 (expr -> ( expr ) .)
    <               reduce using rule 30 (expr -> ( expr ) .)
    ,               reduce using rule 30 (expr -> ( expr ) .)
    )               reduce using rule 30 (expr -> ( expr ) .)
    ]               reduce using rule 30 (expr -> ( expr ) .)
    :               reduce using rule 30 (expr -> ( expr ) .)
    {               reduce using rule 30 (expr -> ( expr ) .)
    BREAK           reduce using rule 30 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 30 (expr -> ( expr ) .)
    RETURN          reduce using rule 30 (expr -> ( expr ) .)
    PRINT           reduce using rule 30 (expr -> ( expr ) .)
    IF              reduce using rule 30 (expr -> ( expr ) .)
    WHILE           reduce using rule 30 (expr -> ( expr ) .)
    FOR             reduce using rule 30 (expr -> ( expr ) .)
    ID              reduce using rule 30 (expr -> ( expr ) .)


state 100

    (27) expr -> ONES ( expr . )
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 109
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 101

    (28) expr -> EYE ( expr . )
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 110
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 102

    (35) expr -> [ array_interior ] .

    ;               reduce using rule 35 (expr -> [ array_interior ] .)
    '               reduce using rule 35 (expr -> [ array_interior ] .)
    +               reduce using rule 35 (expr -> [ array_interior ] .)
    -               reduce using rule 35 (expr -> [ array_interior ] .)
    *               reduce using rule 35 (expr -> [ array_interior ] .)
    /               reduce using rule 35 (expr -> [ array_interior ] .)
    MPLUS           reduce using rule 35 (expr -> [ array_interior ] .)
    MMINUS          reduce using rule 35 (expr -> [ array_interior ] .)
    MMLTP           reduce using rule 35 (expr -> [ array_interior ] .)
    MDIV            reduce using rule 35 (expr -> [ array_interior ] .)
    EQ              reduce using rule 35 (expr -> [ array_interior ] .)
    NEQ             reduce using rule 35 (expr -> [ array_interior ] .)
    GTEQ            reduce using rule 35 (expr -> [ array_interior ] .)
    LTEQ            reduce using rule 35 (expr -> [ array_interior ] .)
    >               reduce using rule 35 (expr -> [ array_interior ] .)
    <               reduce using rule 35 (expr -> [ array_interior ] .)
    ,               reduce using rule 35 (expr -> [ array_interior ] .)
    )               reduce using rule 35 (expr -> [ array_interior ] .)
    ]               reduce using rule 35 (expr -> [ array_interior ] .)
    :               reduce using rule 35 (expr -> [ array_interior ] .)
    {               reduce using rule 35 (expr -> [ array_interior ] .)
    BREAK           reduce using rule 35 (expr -> [ array_interior ] .)
    CONTINUE        reduce using rule 35 (expr -> [ array_interior ] .)
    RETURN          reduce using rule 35 (expr -> [ array_interior ] .)
    PRINT           reduce using rule 35 (expr -> [ array_interior ] .)
    IF              reduce using rule 35 (expr -> [ array_interior ] .)
    WHILE           reduce using rule 35 (expr -> [ array_interior ] .)
    FOR             reduce using rule 35 (expr -> [ array_interior ] .)
    ID              reduce using rule 35 (expr -> [ array_interior ] .)


state 103

    (33) array_interior -> array_interior , expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ,               reduce using rule 33 (array_interior -> array_interior , expr .)
    ;               reduce using rule 33 (array_interior -> array_interior , expr .)
    ]               reduce using rule 33 (array_interior -> array_interior , expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 104

    (62) cond_if -> IF ( expr ) . cond_block
    (63) cond_if -> IF ( expr ) . cond_block ELSE cond_block
    (61) cond_block -> . struct
    (3) struct -> . single_stmt ;
    (4) struct -> . cond_expr
    (5) struct -> . { block_interior }
    (10) single_stmt -> . instruction
    (11) single_stmt -> . assignment
    (58) cond_expr -> . cond_if
    (59) cond_expr -> . cond_while
    (60) cond_expr -> . cond_for
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (62) cond_if -> . IF ( expr ) cond_block
    (63) cond_if -> . IF ( expr ) cond_block ELSE cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 5
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    cond_block                     shift and go to state 111
    struct                         shift and go to state 112
    single_stmt                    shift and go to state 3
    cond_expr                      shift and go to state 4
    instruction                    shift and go to state 6
    assignment                     shift and go to state 7
    cond_if                        shift and go to state 8
    cond_while                     shift and go to state 9
    cond_for                       shift and go to state 10
    lvalue                         shift and go to state 13

state 105

    (70) cond_while -> WHILE ( expr ) . loop_cond_block
    (67) loop_cond_block -> . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . { loop_block_interior }
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 117
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    loop_cond_block                shift and go to state 113
    loop_struct                    shift and go to state 114
    loop_single_stmt               shift and go to state 115
    loop_cond_expr                 shift and go to state 116
    loop_instruction               shift and go to state 118
    assignment                     shift and go to state 119
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122
    lvalue                         shift and go to state 13

state 106

    (71) cond_for -> FOR ID = expr . : expr loop_cond_block
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    :               shift and go to state 128
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 107

    (37) lvalue -> ID [ array_interior ] .

    =               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    PLUSASSIGN      reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MINASSIGN       reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MULTASSIGN      reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    DIVASSIGN       reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    ;               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    '               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    +               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    -               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    *               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    /               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MPLUS           reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MMINUS          reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MMLTP           reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    MDIV            reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    EQ              reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    NEQ             reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    GTEQ            reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    LTEQ            reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    >               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    <               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    ,               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    )               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    ]               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    :               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    {               reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    BREAK           reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    CONTINUE        reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    RETURN          reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    PRINT           reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    IF              reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    WHILE           reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    FOR             reduce using rule 37 (lvalue -> ID [ array_interior ] .)
    ID              reduce using rule 37 (lvalue -> ID [ array_interior ] .)


state 108

    (26) expr -> ZEROS ( expr ) .

    ;               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MMLTP           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MDIV            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    NEQ             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    GTEQ            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    LTEQ            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ]               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    :               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 26 (expr -> ZEROS ( expr ) .)


state 109

    (27) expr -> ONES ( expr ) .

    ;               reduce using rule 27 (expr -> ONES ( expr ) .)
    '               reduce using rule 27 (expr -> ONES ( expr ) .)
    +               reduce using rule 27 (expr -> ONES ( expr ) .)
    -               reduce using rule 27 (expr -> ONES ( expr ) .)
    *               reduce using rule 27 (expr -> ONES ( expr ) .)
    /               reduce using rule 27 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 27 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 27 (expr -> ONES ( expr ) .)
    MMLTP           reduce using rule 27 (expr -> ONES ( expr ) .)
    MDIV            reduce using rule 27 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 27 (expr -> ONES ( expr ) .)
    NEQ             reduce using rule 27 (expr -> ONES ( expr ) .)
    GTEQ            reduce using rule 27 (expr -> ONES ( expr ) .)
    LTEQ            reduce using rule 27 (expr -> ONES ( expr ) .)
    >               reduce using rule 27 (expr -> ONES ( expr ) .)
    <               reduce using rule 27 (expr -> ONES ( expr ) .)
    ,               reduce using rule 27 (expr -> ONES ( expr ) .)
    )               reduce using rule 27 (expr -> ONES ( expr ) .)
    ]               reduce using rule 27 (expr -> ONES ( expr ) .)
    :               reduce using rule 27 (expr -> ONES ( expr ) .)
    {               reduce using rule 27 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 27 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 27 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 27 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 27 (expr -> ONES ( expr ) .)
    IF              reduce using rule 27 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 27 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 27 (expr -> ONES ( expr ) .)
    ID              reduce using rule 27 (expr -> ONES ( expr ) .)


state 110

    (28) expr -> EYE ( expr ) .

    ;               reduce using rule 28 (expr -> EYE ( expr ) .)
    '               reduce using rule 28 (expr -> EYE ( expr ) .)
    +               reduce using rule 28 (expr -> EYE ( expr ) .)
    -               reduce using rule 28 (expr -> EYE ( expr ) .)
    *               reduce using rule 28 (expr -> EYE ( expr ) .)
    /               reduce using rule 28 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 28 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 28 (expr -> EYE ( expr ) .)
    MMLTP           reduce using rule 28 (expr -> EYE ( expr ) .)
    MDIV            reduce using rule 28 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 28 (expr -> EYE ( expr ) .)
    NEQ             reduce using rule 28 (expr -> EYE ( expr ) .)
    GTEQ            reduce using rule 28 (expr -> EYE ( expr ) .)
    LTEQ            reduce using rule 28 (expr -> EYE ( expr ) .)
    >               reduce using rule 28 (expr -> EYE ( expr ) .)
    <               reduce using rule 28 (expr -> EYE ( expr ) .)
    ,               reduce using rule 28 (expr -> EYE ( expr ) .)
    )               reduce using rule 28 (expr -> EYE ( expr ) .)
    ]               reduce using rule 28 (expr -> EYE ( expr ) .)
    :               reduce using rule 28 (expr -> EYE ( expr ) .)
    {               reduce using rule 28 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 28 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 28 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 28 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 28 (expr -> EYE ( expr ) .)
    IF              reduce using rule 28 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 28 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 28 (expr -> EYE ( expr ) .)
    ID              reduce using rule 28 (expr -> EYE ( expr ) .)


state 111

    (62) cond_if -> IF ( expr ) cond_block .
    (63) cond_if -> IF ( expr ) cond_block . ELSE cond_block

    {               reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    RETURN          reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    PRINT           reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    IF              reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    WHILE           reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    FOR             reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    ID              reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    $end            reduce using rule 62 (cond_if -> IF ( expr ) cond_block .)
    ELSE            shift and go to state 129

  ! ELSE            [ reduce using rule 62 (cond_if -> IF ( expr ) cond_block .) ]


state 112

    (61) cond_block -> struct .

    ELSE            reduce using rule 61 (cond_block -> struct .)
    {               reduce using rule 61 (cond_block -> struct .)
    RETURN          reduce using rule 61 (cond_block -> struct .)
    PRINT           reduce using rule 61 (cond_block -> struct .)
    IF              reduce using rule 61 (cond_block -> struct .)
    WHILE           reduce using rule 61 (cond_block -> struct .)
    FOR             reduce using rule 61 (cond_block -> struct .)
    ID              reduce using rule 61 (cond_block -> struct .)
    $end            reduce using rule 61 (cond_block -> struct .)


state 113

    (70) cond_while -> WHILE ( expr ) loop_cond_block .

    {               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    RETURN          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    PRINT           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    IF              reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    WHILE           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    FOR             reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    ID              reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    $end            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    ELSE            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    }               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    INTNUM          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    FLOATNUM        reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    STRING          reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    ZEROS           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    ONES            reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    EYE             reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    (               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    -               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    [               reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    BREAK           reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)
    CONTINUE        reduce using rule 70 (cond_while -> WHILE ( expr ) loop_cond_block .)


state 114

    (67) loop_cond_block -> loop_struct .

    {               reduce using rule 67 (loop_cond_block -> loop_struct .)
    RETURN          reduce using rule 67 (loop_cond_block -> loop_struct .)
    PRINT           reduce using rule 67 (loop_cond_block -> loop_struct .)
    IF              reduce using rule 67 (loop_cond_block -> loop_struct .)
    WHILE           reduce using rule 67 (loop_cond_block -> loop_struct .)
    FOR             reduce using rule 67 (loop_cond_block -> loop_struct .)
    ID              reduce using rule 67 (loop_cond_block -> loop_struct .)
    $end            reduce using rule 67 (loop_cond_block -> loop_struct .)
    ELSE            reduce using rule 67 (loop_cond_block -> loop_struct .)
    }               reduce using rule 67 (loop_cond_block -> loop_struct .)
    INTNUM          reduce using rule 67 (loop_cond_block -> loop_struct .)
    FLOATNUM        reduce using rule 67 (loop_cond_block -> loop_struct .)
    STRING          reduce using rule 67 (loop_cond_block -> loop_struct .)
    ZEROS           reduce using rule 67 (loop_cond_block -> loop_struct .)
    ONES            reduce using rule 67 (loop_cond_block -> loop_struct .)
    EYE             reduce using rule 67 (loop_cond_block -> loop_struct .)
    (               reduce using rule 67 (loop_cond_block -> loop_struct .)
    -               reduce using rule 67 (loop_cond_block -> loop_struct .)
    [               reduce using rule 67 (loop_cond_block -> loop_struct .)
    BREAK           reduce using rule 67 (loop_cond_block -> loop_struct .)
    CONTINUE        reduce using rule 67 (loop_cond_block -> loop_struct .)


state 115

    (12) loop_struct -> loop_single_stmt . ;

    ;               shift and go to state 130


state 116

    (13) loop_struct -> loop_cond_expr .

    {               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    RETURN          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    PRINT           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    IF              reduce using rule 13 (loop_struct -> loop_cond_expr .)
    WHILE           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    FOR             reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ID              reduce using rule 13 (loop_struct -> loop_cond_expr .)
    $end            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ELSE            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    }               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    INTNUM          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    FLOATNUM        reduce using rule 13 (loop_struct -> loop_cond_expr .)
    STRING          reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ZEROS           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    ONES            reduce using rule 13 (loop_struct -> loop_cond_expr .)
    EYE             reduce using rule 13 (loop_struct -> loop_cond_expr .)
    (               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    -               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    [               reduce using rule 13 (loop_struct -> loop_cond_expr .)
    BREAK           reduce using rule 13 (loop_struct -> loop_cond_expr .)
    CONTINUE        reduce using rule 13 (loop_struct -> loop_cond_expr .)


state 117

    (14) loop_struct -> { . loop_block_interior }
    (15) loop_block_interior -> . loop_block_interior expr ;
    (16) loop_block_interior -> . loop_block_interior loop_instruction ;
    (17) loop_block_interior -> . loop_block_interior loop_cond_expr
    (18) loop_block_interior -> . expr ;
    (19) loop_block_interior -> . loop_instruction ;
    (20) loop_block_interior -> . loop_cond_expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    ID              shift and go to state 17
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    loop_block_interior            shift and go to state 131
    expr                           shift and go to state 132
    loop_instruction               shift and go to state 133
    loop_cond_expr                 shift and go to state 134
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122

state 118

    (21) loop_single_stmt -> loop_instruction .

    ;               reduce using rule 21 (loop_single_stmt -> loop_instruction .)


state 119

    (22) loop_single_stmt -> assignment .

    ;               reduce using rule 22 (loop_single_stmt -> assignment .)


state 120

    (64) loop_cond_expr -> loop_cond_if .

    {               reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    RETURN          reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    PRINT           reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    IF              reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    WHILE           reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    FOR             reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    ID              reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    $end            reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    ELSE            reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    }               reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    INTNUM          reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    FLOATNUM        reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    STRING          reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    ZEROS           reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    ONES            reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    EYE             reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    (               reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    -               reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    [               reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    BREAK           reduce using rule 64 (loop_cond_expr -> loop_cond_if .)
    CONTINUE        reduce using rule 64 (loop_cond_expr -> loop_cond_if .)


state 121

    (65) loop_cond_expr -> cond_while .

    {               reduce using rule 65 (loop_cond_expr -> cond_while .)
    RETURN          reduce using rule 65 (loop_cond_expr -> cond_while .)
    PRINT           reduce using rule 65 (loop_cond_expr -> cond_while .)
    IF              reduce using rule 65 (loop_cond_expr -> cond_while .)
    WHILE           reduce using rule 65 (loop_cond_expr -> cond_while .)
    FOR             reduce using rule 65 (loop_cond_expr -> cond_while .)
    ID              reduce using rule 65 (loop_cond_expr -> cond_while .)
    $end            reduce using rule 65 (loop_cond_expr -> cond_while .)
    ELSE            reduce using rule 65 (loop_cond_expr -> cond_while .)
    }               reduce using rule 65 (loop_cond_expr -> cond_while .)
    INTNUM          reduce using rule 65 (loop_cond_expr -> cond_while .)
    FLOATNUM        reduce using rule 65 (loop_cond_expr -> cond_while .)
    STRING          reduce using rule 65 (loop_cond_expr -> cond_while .)
    ZEROS           reduce using rule 65 (loop_cond_expr -> cond_while .)
    ONES            reduce using rule 65 (loop_cond_expr -> cond_while .)
    EYE             reduce using rule 65 (loop_cond_expr -> cond_while .)
    (               reduce using rule 65 (loop_cond_expr -> cond_while .)
    -               reduce using rule 65 (loop_cond_expr -> cond_while .)
    [               reduce using rule 65 (loop_cond_expr -> cond_while .)
    BREAK           reduce using rule 65 (loop_cond_expr -> cond_while .)
    CONTINUE        reduce using rule 65 (loop_cond_expr -> cond_while .)


state 122

    (66) loop_cond_expr -> cond_for .

    {               reduce using rule 66 (loop_cond_expr -> cond_for .)
    RETURN          reduce using rule 66 (loop_cond_expr -> cond_for .)
    PRINT           reduce using rule 66 (loop_cond_expr -> cond_for .)
    IF              reduce using rule 66 (loop_cond_expr -> cond_for .)
    WHILE           reduce using rule 66 (loop_cond_expr -> cond_for .)
    FOR             reduce using rule 66 (loop_cond_expr -> cond_for .)
    ID              reduce using rule 66 (loop_cond_expr -> cond_for .)
    $end            reduce using rule 66 (loop_cond_expr -> cond_for .)
    ELSE            reduce using rule 66 (loop_cond_expr -> cond_for .)
    }               reduce using rule 66 (loop_cond_expr -> cond_for .)
    INTNUM          reduce using rule 66 (loop_cond_expr -> cond_for .)
    FLOATNUM        reduce using rule 66 (loop_cond_expr -> cond_for .)
    STRING          reduce using rule 66 (loop_cond_expr -> cond_for .)
    ZEROS           reduce using rule 66 (loop_cond_expr -> cond_for .)
    ONES            reduce using rule 66 (loop_cond_expr -> cond_for .)
    EYE             reduce using rule 66 (loop_cond_expr -> cond_for .)
    (               reduce using rule 66 (loop_cond_expr -> cond_for .)
    -               reduce using rule 66 (loop_cond_expr -> cond_for .)
    [               reduce using rule 66 (loop_cond_expr -> cond_for .)
    BREAK           reduce using rule 66 (loop_cond_expr -> cond_for .)
    CONTINUE        reduce using rule 66 (loop_cond_expr -> cond_for .)


state 123

    (74) loop_instruction -> BREAK .

    ;               reduce using rule 74 (loop_instruction -> BREAK .)


state 124

    (75) loop_instruction -> CONTINUE .

    ;               reduce using rule 75 (loop_instruction -> CONTINUE .)


state 125

    (76) loop_instruction -> RETURN . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 135
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 126

    (77) loop_instruction -> PRINT . array_interior
    (33) array_interior -> . array_interior , expr
    (34) array_interior -> . expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    array_interior                 shift and go to state 136
    expr                           shift and go to state 36
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 127

    (68) loop_cond_if -> IF . ( expr ) loop_cond_block
    (69) loop_cond_if -> IF . ( expr ) loop_cond_block ELSE loop_cond_block

    (               shift and go to state 137


state 128

    (71) cond_for -> FOR ID = expr : . expr loop_cond_block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 138
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 129

    (63) cond_if -> IF ( expr ) cond_block ELSE . cond_block
    (61) cond_block -> . struct
    (3) struct -> . single_stmt ;
    (4) struct -> . cond_expr
    (5) struct -> . { block_interior }
    (10) single_stmt -> . instruction
    (11) single_stmt -> . assignment
    (58) cond_expr -> . cond_if
    (59) cond_expr -> . cond_while
    (60) cond_expr -> . cond_for
    (72) instruction -> . RETURN expr
    (73) instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (62) cond_if -> . IF ( expr ) cond_block
    (63) cond_if -> . IF ( expr ) cond_block ELSE cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 5
    RETURN          shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    cond_block                     shift and go to state 139
    struct                         shift and go to state 112
    single_stmt                    shift and go to state 3
    cond_expr                      shift and go to state 4
    instruction                    shift and go to state 6
    assignment                     shift and go to state 7
    cond_if                        shift and go to state 8
    cond_while                     shift and go to state 9
    cond_for                       shift and go to state 10
    lvalue                         shift and go to state 13

state 130

    (12) loop_struct -> loop_single_stmt ; .

    {               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    RETURN          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    PRINT           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    IF              reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    WHILE           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    FOR             reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ID              reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    $end            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ELSE            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    }               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    INTNUM          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    FLOATNUM        reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    STRING          reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ZEROS           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    ONES            reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    EYE             reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    (               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    -               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    [               reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    BREAK           reduce using rule 12 (loop_struct -> loop_single_stmt ; .)
    CONTINUE        reduce using rule 12 (loop_struct -> loop_single_stmt ; .)


state 131

    (14) loop_struct -> { loop_block_interior . }
    (15) loop_block_interior -> loop_block_interior . expr ;
    (16) loop_block_interior -> loop_block_interior . loop_instruction ;
    (17) loop_block_interior -> loop_block_interior . loop_cond_expr
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block

    }               shift and go to state 140
    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    ID              shift and go to state 17
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16

    expr                           shift and go to state 141
    loop_instruction               shift and go to state 142
    loop_cond_expr                 shift and go to state 143
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122

state 132

    (18) loop_block_interior -> expr . ;
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               shift and go to state 144
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 133

    (19) loop_block_interior -> loop_instruction . ;

    ;               shift and go to state 145


state 134

    (20) loop_block_interior -> loop_cond_expr .

    }               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    INTNUM          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    FLOATNUM        reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    STRING          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ZEROS           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ONES            reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    EYE             reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    (               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    -               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    [               reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    BREAK           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    CONTINUE        reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    RETURN          reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    PRINT           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    ID              reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    IF              reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    WHILE           reduce using rule 20 (loop_block_interior -> loop_cond_expr .)
    FOR             reduce using rule 20 (loop_block_interior -> loop_cond_expr .)


state 135

    (76) loop_instruction -> RETURN expr .
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               reduce using rule 76 (loop_instruction -> RETURN expr .)
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 136

    (77) loop_instruction -> PRINT array_interior .
    (33) array_interior -> array_interior . , expr

    ;               reduce using rule 77 (loop_instruction -> PRINT array_interior .)
    ,               shift and go to state 72


state 137

    (68) loop_cond_if -> IF ( . expr ) loop_cond_block
    (69) loop_cond_if -> IF ( . expr ) loop_cond_block ELSE loop_cond_block
    (23) expr -> . INTNUM
    (24) expr -> . FLOATNUM
    (25) expr -> . STRING
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . EYE ( expr )
    (29) expr -> . lvalue
    (30) expr -> . ( expr )
    (31) expr -> . - expr
    (32) expr -> . expr '
    (35) expr -> . [ array_interior ]
    (43) expr -> . assignment
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr MPLUS expr
    (49) expr -> . expr MMINUS expr
    (50) expr -> . expr MMLTP expr
    (51) expr -> . expr MDIV expr
    (52) expr -> . expr EQ expr
    (53) expr -> . expr NEQ expr
    (54) expr -> . expr GTEQ expr
    (55) expr -> . expr LTEQ expr
    (56) expr -> . expr > expr
    (57) expr -> . expr < expr
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr

    INTNUM          shift and go to state 23
    FLOATNUM        shift and go to state 24
    STRING          shift and go to state 25
    ZEROS           shift and go to state 26
    ONES            shift and go to state 28
    EYE             shift and go to state 29
    (               shift and go to state 27
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 17

    expr                           shift and go to state 146
    lvalue                         shift and go to state 30
    assignment                     shift and go to state 33

state 138

    (71) cond_for -> FOR ID = expr : expr . loop_cond_block
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr
    (67) loop_cond_block -> . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . { loop_block_interior }
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64
    {               shift and go to state 117
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    loop_cond_block                shift and go to state 147
    loop_struct                    shift and go to state 114
    loop_single_stmt               shift and go to state 115
    loop_cond_expr                 shift and go to state 116
    loop_instruction               shift and go to state 118
    assignment                     shift and go to state 119
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122
    lvalue                         shift and go to state 13

state 139

    (63) cond_if -> IF ( expr ) cond_block ELSE cond_block .

    {               reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    RETURN          reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    PRINT           reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    IF              reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    WHILE           reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    FOR             reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    ID              reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    $end            reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)
    ELSE            reduce using rule 63 (cond_if -> IF ( expr ) cond_block ELSE cond_block .)


state 140

    (14) loop_struct -> { loop_block_interior } .

    {               reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    RETURN          reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    PRINT           reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    IF              reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    WHILE           reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    FOR             reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    ID              reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    $end            reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    ELSE            reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    }               reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    INTNUM          reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    FLOATNUM        reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    STRING          reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    ZEROS           reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    ONES            reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    EYE             reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    (               reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    -               reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    [               reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    BREAK           reduce using rule 14 (loop_struct -> { loop_block_interior } .)
    CONTINUE        reduce using rule 14 (loop_struct -> { loop_block_interior } .)


state 141

    (15) loop_block_interior -> loop_block_interior expr . ;
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    ;               shift and go to state 148
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 142

    (16) loop_block_interior -> loop_block_interior loop_instruction . ;

    ;               shift and go to state 149


state 143

    (17) loop_block_interior -> loop_block_interior loop_cond_expr .

    }               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    INTNUM          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    FLOATNUM        reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    STRING          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ZEROS           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ONES            reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    EYE             reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    (               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    -               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    [               reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    BREAK           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    CONTINUE        reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    RETURN          reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    PRINT           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    ID              reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    IF              reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    WHILE           reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)
    FOR             reduce using rule 17 (loop_block_interior -> loop_block_interior loop_cond_expr .)


state 144

    (18) loop_block_interior -> expr ; .

    }               reduce using rule 18 (loop_block_interior -> expr ; .)
    INTNUM          reduce using rule 18 (loop_block_interior -> expr ; .)
    FLOATNUM        reduce using rule 18 (loop_block_interior -> expr ; .)
    STRING          reduce using rule 18 (loop_block_interior -> expr ; .)
    ZEROS           reduce using rule 18 (loop_block_interior -> expr ; .)
    ONES            reduce using rule 18 (loop_block_interior -> expr ; .)
    EYE             reduce using rule 18 (loop_block_interior -> expr ; .)
    (               reduce using rule 18 (loop_block_interior -> expr ; .)
    -               reduce using rule 18 (loop_block_interior -> expr ; .)
    [               reduce using rule 18 (loop_block_interior -> expr ; .)
    BREAK           reduce using rule 18 (loop_block_interior -> expr ; .)
    CONTINUE        reduce using rule 18 (loop_block_interior -> expr ; .)
    RETURN          reduce using rule 18 (loop_block_interior -> expr ; .)
    PRINT           reduce using rule 18 (loop_block_interior -> expr ; .)
    ID              reduce using rule 18 (loop_block_interior -> expr ; .)
    IF              reduce using rule 18 (loop_block_interior -> expr ; .)
    WHILE           reduce using rule 18 (loop_block_interior -> expr ; .)
    FOR             reduce using rule 18 (loop_block_interior -> expr ; .)


state 145

    (19) loop_block_interior -> loop_instruction ; .

    }               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    INTNUM          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    FLOATNUM        reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    STRING          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ZEROS           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ONES            reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    EYE             reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    (               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    -               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    [               reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    BREAK           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    CONTINUE        reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    RETURN          reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    PRINT           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    ID              reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    IF              reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    WHILE           reduce using rule 19 (loop_block_interior -> loop_instruction ; .)
    FOR             reduce using rule 19 (loop_block_interior -> loop_instruction ; .)


state 146

    (68) loop_cond_if -> IF ( expr . ) loop_cond_block
    (69) loop_cond_if -> IF ( expr . ) loop_cond_block ELSE loop_cond_block
    (32) expr -> expr . '
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . MPLUS expr
    (49) expr -> expr . MMINUS expr
    (50) expr -> expr . MMLTP expr
    (51) expr -> expr . MDIV expr
    (52) expr -> expr . EQ expr
    (53) expr -> expr . NEQ expr
    (54) expr -> expr . GTEQ expr
    (55) expr -> expr . LTEQ expr
    (56) expr -> expr . > expr
    (57) expr -> expr . < expr

    )               shift and go to state 150
    '               shift and go to state 50
    +               shift and go to state 51
    -               shift and go to state 52
    *               shift and go to state 53
    /               shift and go to state 54
    MPLUS           shift and go to state 55
    MMINUS          shift and go to state 56
    MMLTP           shift and go to state 57
    MDIV            shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    GTEQ            shift and go to state 61
    LTEQ            shift and go to state 62
    >               shift and go to state 63
    <               shift and go to state 64


state 147

    (71) cond_for -> FOR ID = expr : expr loop_cond_block .

    {               reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    RETURN          reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    PRINT           reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    IF              reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    WHILE           reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    FOR             reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    ID              reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    $end            reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    ELSE            reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    }               reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    INTNUM          reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    FLOATNUM        reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    STRING          reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    ZEROS           reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    ONES            reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    EYE             reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    (               reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    -               reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    [               reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    BREAK           reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)
    CONTINUE        reduce using rule 71 (cond_for -> FOR ID = expr : expr loop_cond_block .)


state 148

    (15) loop_block_interior -> loop_block_interior expr ; .

    }               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    INTNUM          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    FLOATNUM        reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    STRING          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ZEROS           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ONES            reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    EYE             reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    (               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    -               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    [               reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    BREAK           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    CONTINUE        reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    RETURN          reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    PRINT           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    ID              reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    IF              reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    WHILE           reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)
    FOR             reduce using rule 15 (loop_block_interior -> loop_block_interior expr ; .)


state 149

    (16) loop_block_interior -> loop_block_interior loop_instruction ; .

    }               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    INTNUM          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    FLOATNUM        reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    STRING          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ZEROS           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ONES            reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    EYE             reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    (               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    -               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    [               reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    BREAK           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    CONTINUE        reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    RETURN          reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    PRINT           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    ID              reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    IF              reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    WHILE           reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)
    FOR             reduce using rule 16 (loop_block_interior -> loop_block_interior loop_instruction ; .)


state 150

    (68) loop_cond_if -> IF ( expr ) . loop_cond_block
    (69) loop_cond_if -> IF ( expr ) . loop_cond_block ELSE loop_cond_block
    (67) loop_cond_block -> . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . { loop_block_interior }
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 117
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    loop_cond_block                shift and go to state 151
    loop_struct                    shift and go to state 114
    loop_single_stmt               shift and go to state 115
    loop_cond_expr                 shift and go to state 116
    loop_instruction               shift and go to state 118
    assignment                     shift and go to state 119
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122
    lvalue                         shift and go to state 13

state 151

    (68) loop_cond_if -> IF ( expr ) loop_cond_block .
    (69) loop_cond_if -> IF ( expr ) loop_cond_block . ELSE loop_cond_block

    {               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    RETURN          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    PRINT           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    IF              reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    WHILE           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    FOR             reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    ID              reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    $end            reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    }               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    INTNUM          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    FLOATNUM        reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    STRING          reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    ZEROS           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    ONES            reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    EYE             reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    (               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    -               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    [               reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    BREAK           reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    CONTINUE        reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .)
    ELSE            shift and go to state 152

  ! ELSE            [ reduce using rule 68 (loop_cond_if -> IF ( expr ) loop_cond_block .) ]


state 152

    (69) loop_cond_if -> IF ( expr ) loop_cond_block ELSE . loop_cond_block
    (67) loop_cond_block -> . loop_struct
    (12) loop_struct -> . loop_single_stmt ;
    (13) loop_struct -> . loop_cond_expr
    (14) loop_struct -> . { loop_block_interior }
    (21) loop_single_stmt -> . loop_instruction
    (22) loop_single_stmt -> . assignment
    (64) loop_cond_expr -> . loop_cond_if
    (65) loop_cond_expr -> . cond_while
    (66) loop_cond_expr -> . cond_for
    (74) loop_instruction -> . BREAK
    (75) loop_instruction -> . CONTINUE
    (76) loop_instruction -> . RETURN expr
    (77) loop_instruction -> . PRINT array_interior
    (38) assignment -> . lvalue = expr
    (39) assignment -> . lvalue PLUSASSIGN expr
    (40) assignment -> . lvalue MINASSIGN expr
    (41) assignment -> . lvalue MULTASSIGN expr
    (42) assignment -> . lvalue DIVASSIGN expr
    (68) loop_cond_if -> . IF ( expr ) loop_cond_block
    (69) loop_cond_if -> . IF ( expr ) loop_cond_block ELSE loop_cond_block
    (70) cond_while -> . WHILE ( expr ) loop_cond_block
    (71) cond_for -> . FOR ID = expr : expr loop_cond_block
    (36) lvalue -> . ID
    (37) lvalue -> . ID [ array_interior ]

    {               shift and go to state 117
    BREAK           shift and go to state 123
    CONTINUE        shift and go to state 124
    RETURN          shift and go to state 125
    PRINT           shift and go to state 126
    IF              shift and go to state 127
    WHILE           shift and go to state 15
    FOR             shift and go to state 16
    ID              shift and go to state 17

    loop_cond_block                shift and go to state 153
    loop_struct                    shift and go to state 114
    loop_single_stmt               shift and go to state 115
    loop_cond_expr                 shift and go to state 116
    loop_instruction               shift and go to state 118
    assignment                     shift and go to state 119
    loop_cond_if                   shift and go to state 120
    cond_while                     shift and go to state 121
    cond_for                       shift and go to state 122
    lvalue                         shift and go to state 13

state 153

    (69) loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .

    {               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    RETURN          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    PRINT           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    IF              reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    WHILE           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    FOR             reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    ID              reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    $end            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    ELSE            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    }               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    INTNUM          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    FLOATNUM        reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    STRING          reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    ZEROS           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    ONES            reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    EYE             reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    (               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    -               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    [               reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    BREAK           reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)
    CONTINUE        reduce using rule 69 (loop_cond_if -> IF ( expr ) loop_cond_block ELSE loop_cond_block .)

